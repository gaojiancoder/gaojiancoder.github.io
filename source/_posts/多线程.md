---
title: 多线程
top: false
cover: false
toc: true
mathjax: true
date: 2021-08-15 17:11:18
password:
summary:
tags: notes
categories: Thread
---

## 多线程

### 创建多线程方法

1.继承Thread类

2.实现Runnable接口

3.实现Callable接口

### 一.继承Thread类

```java
//创建线程方式yi：继承Thread类，重写run()方法，调用start开启线程
public class TestThread01 extends Thread{
    @Override
    public void run() {
        super.run();
        //run方法线程体
        for (int i = 0; i < 20; i++) {
            System.out.println("我在看代码---"+i);
        }
    }
    public static void main(String[] args) {
        //main线程，主线程
        //创建一个线程对象
        TestThread01 thread01 = new TestThread01();
        //调用start（）方法开启线程
        thread01.start();
        for (int i = 0; i < 20; i++) {
            System.out.println("我在学习---"+i);
        }
    }
}
```

总结：线程开启不一定立即执行，由cpu调度实行

#### 下载图片案例

```java
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;
public class Download extends Thread{
    private String url;
    private String name;
    public Download(String url,String name){
        this.url =url;
        this.name=name;
    }
    @Override
    public void run() {
        WebDownload download = new WebDownload();
        download.download(url,name);
        System.out.println("下载了文件："+name);
    }
    public static void main(String[] args) {
        Download download=new Download("https://images3.alphacoders.com/911/911582.jpg","1.png");
        download.start();
    }
    //下载器
    class WebDownload{
        public void download(String url,String name){
            try {
                FileUtils.copyURLToFile(new URL(url),new File(name));
            } catch (IOException e) {
                e.printStackTrace();
                System.out.println("io异常");
            }
        }
    }

}
```

### 二.实现Runnable接口

```java
//方式二：实现runnable接口，重写run，执行线程需要丢入runnable接口实现类，调用start()
public class TestThread implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println("看我：" + i);
        }
    }

    public static void main(String[] args) {
        TestThread thread = new TestThread();//创建接口的实现类
        Thread thread1 = new Thread(thread);//创建线程对象
        thread1.start();

        for (int i = 0; i < 20; i++) {
            System.out.println("看你：" + i);
        }
    }
}
```

![1](1.png)

买票案例测试

```java
public class TestThread implements Runnable{
    //定义票
    private int ticketNums =10;
    @Override
    public void run() {
        while (true){
            if (ticketNums<=0){
                break;
            }
            System.out.println(Thread.currentThread().getName()+"-->拿到了第"+ticketNums--+"张票");
        }
    }
    public static void main(String[] args) {
        TestThread testThread = new TestThread();
        new Thread(testThread,"小明").start();
        new Thread(testThread,"小高").start();
        new Thread(testThread,"我").start();
    }
}
```

#### 龟兔赛跑案例

```java
public class Race implements Runnable{
    //胜利者
    private String winner;
    @Override
    public void run() {
        for (int i = 0; i <= 100; i++) {

            if (Thread.currentThread().getName().equals("2")&&i%10==0){
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            boolean flag = gameOver(i);
            if (flag){
                break;
            }
            System.out.println(Thread.currentThread().getName()+"跑了"+i+"步");

        }
    }

    private boolean gameOver(int steps){
        if (winner!=null){
            return true;
        }{
            if (steps >=100){
                winner = Thread.currentThread().getName();
                System.out.println(winner+"赢了");
                return true;
            }
        }
        return false;
    }


    public static void main(String[] args) {
        Race race = new Race();
        new Thread(race,"1").start();
        new Thread(race,"2").start();
    }

}
```

总结：多线程操作同一个资源的情况下，线程不安全，数据紊乱

### 三实现Callable接口

```java
import org.apache.commons.io.FileUtils;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.concurrent.*;

//方式三：实现Callable方法
public class TestCallable implements Callable<Boolean> {
    private String url;
    private String name;
    public TestCallable(String url, String name) {
        this.url = url;
        this.name = name;
    }
    
    @Override
    public Boolean call() {
        WebDownload webDownload = new WebDownload();
        webDownload.download(url,name);
        System.out.println("下载了文件：" + name);
        return true;
    }
    
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        TestCallable download = new TestCallable("https://images3.alphacoders.com/911/911582.jpg", "1.png");
        ExecutorService pool = Executors.newFixedThreadPool(1);
        Future<Boolean> r1 =pool.submit(download);
        boolean rs1 = r1.get();
        pool.shutdown();
    }
    
    class WebDownload {
        public void download(String url, String name) {
            try {
                FileUtils.copyURLToFile(new URL(url), new File(name));
            } catch (IOException e) {
                e.printStackTrace();
                System.out.println("io异常");
            }
        }
    }

}
```

### 四.Lamda表达式

#### 函数式接口

- 理解FUnctional Interface（函数式接口）是学习的关键

- 任何接口，如果只包含唯一一个抽象方法，那么他就是一个函数式接口
- 我们可以通过lambda表达式来创建改接口的对象

![2](2.png)

#### 代码实现

```java
public class TestLambda02 {
    public static void main(String[] args) {
 ILove love =s->System.out.println("I louve"+s );
        love.love("小明");
    }
}

interface ILove{
    void love(String s);
}
```

### 五.线程

#### 线程状态

- 创建状态
- 就绪状态
- 运行状态
- 阻塞状态
- 死亡状态

#### 线程方法

setPriority ：更改线程的优先级

sleep(long):指定毫秒内沉睡

join：插队

yield：暂停当前线程对象，执行其他线程

isAlive：测试线程是否处于活动状态

#### 停止方法测试代码实现

```java
public class TestStop implements Runnable {
    //设置标志位
    private boolean flag = true;

    @Override
    public void run() {
        int i = 120;
        while (flag) {
            System.out.println("run Thread ----------------" + (i++));
        }
    }
    public void stop() {
        this.flag = false;
    }

    public static void main(String[] args) throws InterruptedException {
        TestStop testStop = new TestStop();
        new Thread(testStop).start();
//        Thread.sleep(100);
        for (int i = 0; i < 100; i++) {
            System.out.println("main" + i);
            if (i == 90) {
                testStop.stop();
                System.out.println("停止");
            }
        }
    }
}
```

#### 线程睡眠代码实现

模拟网络延迟：放大问题的发生性，多线程操作不安全。

```java
public class TestSleep implements Runnable{
    private int ticketNums =10;
    @Override
    public void run() {
        while (true){
            if (ticketNums<=0){
                break;
            }
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+"-->拿到了第"+ticketNums--+"张票");
        }

    }
    public static void main(String[] args) {
        TestSleep testSleep = new TestSleep();
        new Thread(testSleep,"小明").start();
        new Thread(testSleep,"小高").start();
        new Thread(testSleep,"我").start();


    }
}
```

#### 测试倒计时代码实现

```java
public class TestSleep2 implements Runnable {
    private int date = 10;

    public static void main(String[] args) {
        TestSleep2 testSleep2 = new TestSleep2();
        new Thread(testSleep2).start();
    }

    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(date++);
            if (date <= 0) {
                break;
            }
        }
    }
}
```

#### 获取当前时间代码实现

```java
public class TestSleep2 implements Runnable {
    public static void main(String[] args) {
        Date date = new Date(System.currentTimeMillis());//获取系统当前时间
        while (true) {
            try {
                Thread.sleep(1000);
                System.out.println(new SimpleDateFormat("HH:mm:ss").format(date));
                date = new Date(System.currentTimeMillis());//更新当前时间
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    }

    @Override
    public void run() {
    }
}
```

### 六.线程同步

#### 同步方法

synchronized：在方法中加入以实现给方法上锁

```java
public class unSafeBuy {
    public static void main(String[] args) {
        BuyTicker buyTicker = new BuyTicker();
        new Thread(buyTicker, "a").start();
        new Thread(buyTicker, "c").start();
        new Thread(buyTicker, "b").start();

    }
}

class BuyTicker implements Runnable {

    private boolean flag = true;
    private int ticket = 10;

    @Override
    public void run() {
        while (flag) {
            try {
                buy();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }


    private synchronized void buy() throws InterruptedException {
        if (ticket <= 0) {
            flag = false;
            return;
        }
        Thread.sleep(1);
        System.out.println(Thread.currentThread().getName() + "拿到" + ticket--);
    }

}
```

#### lock锁

使用方法在类中定义

```java
private final  ReentrantLock lock =new ReenTrantLock();
```

然后在void方法中使用lock.lock给线程上锁用try ，finally语句

lock.unlock解锁写入finally中

![](5.png)

