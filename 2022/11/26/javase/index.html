<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JavaSE, 一个小白的成功之路">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JavaSE | 一个小白的成功之路</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">一个小白的成功之路</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">一个小白的成功之路</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/gaojiancoder" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/gaojiancoder" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/12.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JavaSE</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Study/">
                                <span class="chip bg-color">Study</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/JavaSE/" class="post-category">
                                JavaSE
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-11-26
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    17.2k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    82 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        
        <!-- 代码块折行 -->
        <style type="text/css">
            code[class*="language-"], pre[class*="language-"] { white-space: pre-wrap !important; }
        </style>
        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h1><h2 id="1-Comparable-内置比较接口"><a href="#1-Comparable-内置比较接口" class="headerlink" title="1.Comparable 内置比较接口"></a>1.Comparable 内置比较接口</h2><p>在使用外置比较器时发现一个问题：重复代码太多能合并掉吗？可以使用内置比较器。内置和外置的选择：外置灵活，内置死板。我们当前的情况是：list1，list2，list3排序规则都是一样的，使用内置自然会减少代码量。如果三个list的排序规则各不一样，内置就无法实现了，必须用外置</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Random;

public class Poker implements Comparable&lt;Poker&gt;&#123;
    String color;
    String number;
    boolean bigJoker;
    boolean littleJoker;

    public String toString() &#123;

        return bigJoker &#x3D;&#x3D; false &amp;&amp; littleJoker &#x3D;&#x3D; false ? color + number : bigJoker &#x3D;&#x3D; true ? &quot;大王&quot; : &quot;小王&quot;;
    &#125;


    public static void main(String[] args) &#123;
        &#x2F;&#x2F;-- 0.提供容器：ArrayList
        ArrayList&lt;Poker&gt; list &#x3D; new ArrayList&lt;&gt;();

        &#x2F;&#x2F;-- 1.构建54张扑克牌
        String[] colors &#x3D; &#123;&quot;♠&quot;, &quot;♥&quot;, &quot;♣&quot;, &quot;♦&quot;&#125;;
        String[] numbers &#x3D; &#123;&quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;J&quot;, &quot;Q&quot;, &quot;K&quot;, &quot;A&quot;, &quot;2&quot;&#125;;
        for (String color : colors) &#123;
            for (String number : numbers) &#123;
                Poker p &#x3D; new Poker();
                p.color &#x3D; color;
                p.number &#x3D; number;
                list.add(p);
            &#125;
        &#125;

        &#x2F;&#x2F;-- 添加大小王
        Poker bigPoker &#x3D; new Poker();
        bigPoker.color &#x3D; &quot;&quot;;
        bigPoker.number &#x3D; &quot;&quot;;
        bigPoker.bigJoker &#x3D; true;
        list.add(bigPoker);

        Poker littlePoker &#x3D; new Poker();
        littlePoker.littleJoker &#x3D; true;
        littlePoker.color &#x3D; &quot;&quot;;
        littlePoker.number &#x3D; &quot;&quot;;
        list.add(littlePoker);

        &#x2F;&#x2F;-- 2.输出54张牌
        System.out.println(list);

        &#x2F;&#x2F;-- 3.洗牌
        Collections.shuffle(list);

        System.out.println(list);

        &#x2F;&#x2F;-- 4.发牌
        &#x2F;&#x2F;-- 把前17张牌，从list中截取出来，组成一个新的list  不能这么发牌
        &#x2F;&#x2F;List&lt;Poker&gt; pokers &#x3D; list.subList(0, 17);

        ArrayList&lt;Poker&gt; list1 &#x3D; new ArrayList&lt;&gt;();
        ArrayList&lt;Poker&gt; list2 &#x3D; new ArrayList&lt;&gt;();
        ArrayList&lt;Poker&gt; list3 &#x3D; new ArrayList&lt;&gt;();

        for (int i &#x3D; 0; i &lt; 51; i++) &#123;
            if (i % 3 &#x3D;&#x3D; 0) &#123;
                list3.add(list.get(i));
            &#125; else if (i % 3 &#x3D;&#x3D; 1) &#123;
                list1.add(list.get(i));
            &#125; else if (i % 3 &#x3D;&#x3D; 2) &#123;
                list2.add(list.get(i));
            &#125;
        &#125;

        int isLandlord &#x3D; 0;
        Random random &#x3D; new Random();
        isLandlord &#x3D; random.nextInt(3) + 1;

        if (isLandlord &#x3D;&#x3D; 1) &#123;
            &#x2F;&#x2F;-- 一次性加入多个数据
            &#x2F;&#x2F;-- int fromIndex, int toIndex   fromIndex 是包含的，toIndex是排它 【fromIndex，toIndex）
            list1.addAll(list.subList(51, 54));
        &#125; else if (isLandlord &#x3D;&#x3D; 2) &#123;
            list2.addAll(list.subList(51, 54));
        &#125; else &#123;
            list3.addAll(list.subList(51, 54));
        &#125;

        &#x2F;&#x2F;-- 排序
        Collections.sort(list1);
        Collections.sort(list2);
        Collections.sort(list3);

        System.out.println(list1);
        System.out.println(list2);
        System.out.println(list3);
    &#125;

    @Override
    public int compareTo(Poker o) &#123;
        &#x2F;&#x2F;-- p1.compareTo(p2)
        &#x2F;&#x2F;-- 在compareTo方法内部来说，谁调用它谁就是this
        &#x2F;&#x2F;-- Java 有一个关键字：this，代表当前！！
        &#x2F;&#x2F;-- 指定比较规则！
        String n1 &#x3D; this.number;
        String n2 &#x3D; o.number;
        int o1Value &#x3D; 0 , o2Value &#x3D; 0 ;
        &#x2F;&#x2F;-- 面值有3中类型：数字（3-10） 字符（J Q K A 2） 文字（大王  小王）
        &#x2F;&#x2F;-- 统一单位-》int

        if (n1.equalsIgnoreCase(&quot;J&quot;))&#123;
            o1Value &#x3D; 11;
        &#125;else if (n1.equalsIgnoreCase(&quot;Q&quot;))&#123;
            o1Value &#x3D; 12;
        &#125;else if (n1.equalsIgnoreCase(&quot;K&quot;))&#123;
            o1Value &#x3D; 13;
        &#125;else if (n1.equalsIgnoreCase(&quot;A&quot;))&#123;
            o1Value &#x3D; 14;
        &#125;else if (n1.equalsIgnoreCase(&quot;2&quot;))&#123;
            o1Value &#x3D; 15;
        &#125;else if (n1.equals(&quot;&quot;))&#123;
            if (this.bigJoker)&#123;
                o1Value &#x3D; 17;
            &#125;
            if (this.littleJoker)&#123;
                o1Value &#x3D; 16;
            &#125;
        &#125;else&#123;
            &#x2F;&#x2F;-- n1 &#x3D;&gt; &quot;3&quot;,-&gt;&quot;10&quot;
            o1Value &#x3D; Integer.parseInt(n1);
        &#125;


        if (n2.equalsIgnoreCase(&quot;J&quot;))&#123;
            o2Value &#x3D; 11;
        &#125;else if (n2.equalsIgnoreCase(&quot;Q&quot;))&#123;
            o2Value &#x3D; 12;
        &#125;else if (n2.equalsIgnoreCase(&quot;K&quot;))&#123;
            o2Value &#x3D; 13;
        &#125;else if (n2.equalsIgnoreCase(&quot;A&quot;))&#123;
            o2Value &#x3D; 14;
        &#125;else if (n2.equalsIgnoreCase(&quot;2&quot;))&#123;
            o2Value &#x3D; 15;
        &#125;else if (n2.equals(&quot;&quot;))&#123;
            if (o.bigJoker)&#123;
                o2Value &#x3D; 17;
            &#125;
            if (o.littleJoker)&#123;
                o2Value &#x3D; 16;
            &#125;
        &#125;else&#123;
            &#x2F;&#x2F;-- n1 &#x3D;&gt; &quot;3&quot;,-&gt;&quot;10&quot;
            o2Value &#x3D; Integer.parseInt(n2);
        &#125;
        return o1Value - o2Value;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-Comparator-外置比较接口"><a href="#2-Comparator-外置比较接口" class="headerlink" title="2.Comparator 外置比较接口"></a>2.Comparator 外置比较接口</h2><p>使用率较高,只要是引用类型，它们的排序基本都是通过Comparator或者Comparable来实现的，具体的内容如下</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Comparator&lt;T&gt; &#123;
    int compare(T o1, T o2);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在 Comparator 接口中定义了一个行为：compare。compare 英语单词字面意思：比较。小括号里的o1和o2做比较！比较的方式我们自定义，但是最终的结果它是有约定的</p>
<ul>
<li>正数  : o1 &gt; o2</li>
<li>零      : o1 = o2</li>
<li>负数  :  o1 &lt; o2</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Random;

public class Poker &#123;
    String color;
    String number;
    boolean bigJoker;
    boolean littleJoker;

    public String toString() &#123;

        return bigJoker &#x3D;&#x3D; false &amp;&amp; littleJoker &#x3D;&#x3D; false ? color + number : bigJoker &#x3D;&#x3D; true ? &quot;大王&quot; : &quot;小王&quot;;
    &#125;


    public static void main(String[] args) &#123;
        &#x2F;&#x2F;-- 0.提供容器：ArrayList
        ArrayList&lt;Poker&gt; list &#x3D; new ArrayList&lt;&gt;();

        &#x2F;&#x2F;-- 1.构建54张扑克牌
        String[] colors &#x3D; &#123;&quot;♠&quot;, &quot;♥&quot;, &quot;♣&quot;, &quot;♦&quot;&#125;;
        String[] numbers &#x3D; &#123;&quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;J&quot;, &quot;Q&quot;, &quot;K&quot;, &quot;A&quot;, &quot;2&quot;&#125;;
        for (String color : colors) &#123;
            for (String number : numbers) &#123;
                Poker p &#x3D; new Poker();
                p.color &#x3D; color;
                p.number &#x3D; number;
                list.add(p);
            &#125;
        &#125;

        &#x2F;&#x2F;-- 添加大小王
        Poker bigPoker &#x3D; new Poker();
        bigPoker.color &#x3D; &quot;&quot;;
        bigPoker.number &#x3D; &quot;&quot;;
        bigPoker.bigJoker &#x3D; true;
        list.add(bigPoker);

        Poker littlePoker &#x3D; new Poker();
        littlePoker.littleJoker &#x3D; true;
        littlePoker.color &#x3D; &quot;&quot;;
        littlePoker.number &#x3D; &quot;&quot;;
        list.add(littlePoker);

        &#x2F;&#x2F;-- 2.输出54张牌
        System.out.println(list);

        &#x2F;&#x2F;-- 3.洗牌
        Collections.shuffle(list);

        System.out.println(list);

        &#x2F;&#x2F;-- 4.发牌
        &#x2F;&#x2F;-- 把前17张牌，从list中截取出来，组成一个新的list  不能这么发牌
        &#x2F;&#x2F;List&lt;Poker&gt; pokers &#x3D; list.subList(0, 17);

        ArrayList&lt;Poker&gt; list1 &#x3D; new ArrayList&lt;&gt;();
        ArrayList&lt;Poker&gt; list2 &#x3D; new ArrayList&lt;&gt;();
        ArrayList&lt;Poker&gt; list3 &#x3D; new ArrayList&lt;&gt;();

        for (int i &#x3D; 0; i &lt; 51; i++) &#123;
            if (i % 3 &#x3D;&#x3D; 0) &#123;
                list3.add(list.get(i));
            &#125; else if (i % 3 &#x3D;&#x3D; 1) &#123;
                list1.add(list.get(i));
            &#125; else if (i % 3 &#x3D;&#x3D; 2) &#123;
                list2.add(list.get(i));
            &#125;
        &#125;

        int isLandlord &#x3D; 0;
        Random random &#x3D; new Random();
        isLandlord &#x3D; random.nextInt(3) + 1;

        if (isLandlord &#x3D;&#x3D; 1) &#123;
            &#x2F;&#x2F;-- 一次性加入多个数据
            &#x2F;&#x2F;-- int fromIndex, int toIndex   fromIndex 是包含的，toIndex是排它 【fromIndex，toIndex）
            list1.addAll(list.subList(51, 54));
        &#125; else if (isLandlord &#x3D;&#x3D; 2) &#123;
            list2.addAll(list.subList(51, 54));
        &#125; else &#123;
            list3.addAll(list.subList(51, 54));
        &#125;

        list1.sort(new Comparator&lt;Poker&gt;() &#123;
            @Override
            public int compare(Poker o1, Poker o2) &#123;
                &#x2F;&#x2F;-- 指定比较规则！
                String n1 &#x3D; o1.number;
                String n2 &#x3D; o2.number;
                int o1Value &#x3D; 0 , o2Value &#x3D; 0 ;
                &#x2F;&#x2F;-- 面值有3中类型：数字（3-10） 字符（J Q K A 2） 文字（大王  小王）
                &#x2F;&#x2F;-- 统一单位-》int

                if (n1.equalsIgnoreCase(&quot;J&quot;))&#123;
                    o1Value &#x3D; 11;
                &#125;else if (n1.equalsIgnoreCase(&quot;Q&quot;))&#123;
                    o1Value &#x3D; 12;
                &#125;else if (n1.equalsIgnoreCase(&quot;K&quot;))&#123;
                    o1Value &#x3D; 13;
                &#125;else if (n1.equalsIgnoreCase(&quot;A&quot;))&#123;
                    o1Value &#x3D; 14;
                &#125;else if (n1.equalsIgnoreCase(&quot;2&quot;))&#123;
                    o1Value &#x3D; 15;
                &#125;else if (n1.equals(&quot;&quot;))&#123;
                    if (o1.bigJoker)&#123;
                        o1Value &#x3D; 17;
                    &#125;
                    if (o1.littleJoker)&#123;
                        o1Value &#x3D; 16;
                    &#125;
                &#125;else&#123;
                    &#x2F;&#x2F;-- n1 &#x3D;&gt; &quot;3&quot;,-&gt;&quot;10&quot;
                    o1Value &#x3D; Integer.parseInt(n1);
                &#125;


                if (n2.equalsIgnoreCase(&quot;J&quot;))&#123;
                    o2Value &#x3D; 11;
                &#125;else if (n2.equalsIgnoreCase(&quot;Q&quot;))&#123;
                    o2Value &#x3D; 12;
                &#125;else if (n2.equalsIgnoreCase(&quot;K&quot;))&#123;
                    o2Value &#x3D; 13;
                &#125;else if (n2.equalsIgnoreCase(&quot;A&quot;))&#123;
                    o2Value &#x3D; 14;
                &#125;else if (n2.equalsIgnoreCase(&quot;2&quot;))&#123;
                    o2Value &#x3D; 15;
                &#125;else if (n2.equals(&quot;&quot;))&#123;
                    if (o2.bigJoker)&#123;
                        o2Value &#x3D; 17;
                    &#125;
                    if (o2.littleJoker)&#123;
                        o2Value &#x3D; 16;
                    &#125;
                &#125;else&#123;
                    &#x2F;&#x2F;-- n1 &#x3D;&gt; &quot;3&quot;,-&gt;&quot;10&quot;
                    o2Value &#x3D; Integer.parseInt(n2);
                &#125;
                return o1Value - o2Value;
            &#125;
        &#125;);
        list2.sort(new Comparator&lt;Poker&gt;() &#123;
            @Override
            public int compare(Poker o1, Poker o2) &#123;
                &#x2F;&#x2F;-- 指定比较规则！
                String n1 &#x3D; o1.number;
                String n2 &#x3D; o2.number;
                int o1Value &#x3D; 0 , o2Value &#x3D; 0 ;
                &#x2F;&#x2F;-- 面值有3中类型：数字（3-10） 字符（J Q K A 2） 文字（大王  小王）
                &#x2F;&#x2F;-- 统一单位-》int

                if (n1.equalsIgnoreCase(&quot;J&quot;))&#123;
                    o1Value &#x3D; 11;
                &#125;else if (n1.equalsIgnoreCase(&quot;Q&quot;))&#123;
                    o1Value &#x3D; 12;
                &#125;else if (n1.equalsIgnoreCase(&quot;K&quot;))&#123;
                    o1Value &#x3D; 13;
                &#125;else if (n1.equalsIgnoreCase(&quot;A&quot;))&#123;
                    o1Value &#x3D; 14;
                &#125;else if (n1.equalsIgnoreCase(&quot;2&quot;))&#123;
                    o1Value &#x3D; 15;
                &#125;else if (n1.equals(&quot;&quot;))&#123;
                    if (o1.bigJoker)&#123;
                        o1Value &#x3D; 17;
                    &#125;
                    if (o1.littleJoker)&#123;
                        o1Value &#x3D; 16;
                    &#125;
                &#125;else&#123;
                    &#x2F;&#x2F;-- n1 &#x3D;&gt; &quot;3&quot;,-&gt;&quot;10&quot;
                    o1Value &#x3D; Integer.parseInt(n1);
                &#125;


                if (n2.equalsIgnoreCase(&quot;J&quot;))&#123;
                    o2Value &#x3D; 11;
                &#125;else if (n2.equalsIgnoreCase(&quot;Q&quot;))&#123;
                    o2Value &#x3D; 12;
                &#125;else if (n2.equalsIgnoreCase(&quot;K&quot;))&#123;
                    o2Value &#x3D; 13;
                &#125;else if (n2.equalsIgnoreCase(&quot;A&quot;))&#123;
                    o2Value &#x3D; 14;
                &#125;else if (n2.equalsIgnoreCase(&quot;2&quot;))&#123;
                    o2Value &#x3D; 15;
                &#125;else if (n2.equals(&quot;&quot;))&#123;
                    if (o2.bigJoker)&#123;
                        o2Value &#x3D; 17;
                    &#125;
                    if (o2.littleJoker)&#123;
                        o2Value &#x3D; 16;
                    &#125;
                &#125;else&#123;
                    &#x2F;&#x2F;-- n1 &#x3D;&gt; &quot;3&quot;,-&gt;&quot;10&quot;
                    o2Value &#x3D; Integer.parseInt(n2);
                &#125;
                return o1Value - o2Value;
            &#125;
        &#125;);
        list3.sort(new Comparator&lt;Poker&gt;() &#123;
            @Override
            public int compare(Poker o1, Poker o2) &#123;
                &#x2F;&#x2F;-- 指定比较规则！
                String n1 &#x3D; o1.number;
                String n2 &#x3D; o2.number;
                int o1Value &#x3D; 0 , o2Value &#x3D; 0 ;
                &#x2F;&#x2F;-- 面值有3中类型：数字（3-10） 字符（J Q K A 2） 文字（大王  小王）
                &#x2F;&#x2F;-- 统一单位-》int

                if (n1.equalsIgnoreCase(&quot;J&quot;))&#123;
                    o1Value &#x3D; 11;
                &#125;else if (n1.equalsIgnoreCase(&quot;Q&quot;))&#123;
                    o1Value &#x3D; 12;
                &#125;else if (n1.equalsIgnoreCase(&quot;K&quot;))&#123;
                    o1Value &#x3D; 13;
                &#125;else if (n1.equalsIgnoreCase(&quot;A&quot;))&#123;
                    o1Value &#x3D; 14;
                &#125;else if (n1.equalsIgnoreCase(&quot;2&quot;))&#123;
                    o1Value &#x3D; 15;
                &#125;else if (n1.equals(&quot;&quot;))&#123;
                    if (o1.bigJoker)&#123;
                        o1Value &#x3D; 17;
                    &#125;
                    if (o1.littleJoker)&#123;
                        o1Value &#x3D; 16;
                    &#125;
                &#125;else&#123;
                    &#x2F;&#x2F;-- n1 &#x3D;&gt; &quot;3&quot;,-&gt;&quot;10&quot;
                    o1Value &#x3D; Integer.parseInt(n1);
                &#125;


                if (n2.equalsIgnoreCase(&quot;J&quot;))&#123;
                    o2Value &#x3D; 11;
                &#125;else if (n2.equalsIgnoreCase(&quot;Q&quot;))&#123;
                    o2Value &#x3D; 12;
                &#125;else if (n2.equalsIgnoreCase(&quot;K&quot;))&#123;
                    o2Value &#x3D; 13;
                &#125;else if (n2.equalsIgnoreCase(&quot;A&quot;))&#123;
                    o2Value &#x3D; 14;
                &#125;else if (n2.equalsIgnoreCase(&quot;2&quot;))&#123;
                    o2Value &#x3D; 15;
                &#125;else if (n2.equals(&quot;&quot;))&#123;
                    if (o2.bigJoker)&#123;
                        o2Value &#x3D; 17;
                    &#125;
                    if (o2.littleJoker)&#123;
                        o2Value &#x3D; 16;
                    &#125;
                &#125;else&#123;
                    &#x2F;&#x2F;-- n1 &#x3D;&gt; &quot;3&quot;,-&gt;&quot;10&quot;
                    o2Value &#x3D; Integer.parseInt(n2);
                &#125;
                return o1Value - o2Value;
            &#125;
        &#125;);

        System.out.println(list1);
        System.out.println(list2);
        System.out.println(list3);
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="3-equals的作用"><a href="#3-equals的作用" class="headerlink" title="3.equals的作用"></a>3.equals的作用</h2><p>判断变量所保存的数据是否相等，要区分数据类型。如果是原生类型变量所代表的内存空间内保存的就是值本身，所以两个原生变量直接用 <code>== </code>来判断相等。但是如果是引用类型的变量，引用变量在栈中所存储的是堆中的空间，如果两个引用变量用 <code>==</code> 来表示是否相等，等价于比较的是堆中两片内存空间的地址，所以一定是false</p>
<p><img src="/2022/11/26/javase/equse.png"></p>
<h3 id="3-1equals重写方式"><a href="#3-1equals重写方式" class="headerlink" title="3.1equals重写方式"></a>3.1equals重写方式</h3><p>在equals源码中有一段注释，规定了重写equals时要遵守的5个原则</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
     * Indicates whether some other object is &quot;equal to&quot; this one.
     * &lt;p&gt;
     * The &#123;@code equals&#125; method implements an equivalence relation
     * on non-null object references:
     * &lt;ul&gt;
     * &lt;li&gt;It is &lt;i&gt;reflexive&lt;&#x2F;i&gt;: for any non-null reference value
     *     &#123;@code x&#125;, &#123;@code x.equals(x)&#125; should return
     *     &#123;@code true&#125;.
     * &lt;li&gt;It is &lt;i&gt;symmetric&lt;&#x2F;i&gt;: for any non-null reference values
     *     &#123;@code x&#125; and &#123;@code y&#125;, &#123;@code x.equals(y)&#125;
     *     should return &#123;@code true&#125; if and only if
     *     &#123;@code y.equals(x)&#125; returns &#123;@code true&#125;.
     * &lt;li&gt;It is &lt;i&gt;transitive&lt;&#x2F;i&gt;: for any non-null reference values
     *     &#123;@code x&#125;, &#123;@code y&#125;, and &#123;@code z&#125;, if
     *     &#123;@code x.equals(y)&#125; returns &#123;@code true&#125; and
     *     &#123;@code y.equals(z)&#125; returns &#123;@code true&#125;, then
     *     &#123;@code x.equals(z)&#125; should return &#123;@code true&#125;.
     * &lt;li&gt;It is &lt;i&gt;consistent&lt;&#x2F;i&gt;: for any non-null reference values
     *     &#123;@code x&#125; and &#123;@code y&#125;, multiple invocations of
     *     &#123;@code x.equals(y)&#125; consistently return &#123;@code true&#125;
     *     or consistently return &#123;@code false&#125;, provided no
     *     information used in &#123;@code equals&#125; comparisons on the
     *     objects is modified.
     * &lt;li&gt;For any non-null reference value &#123;@code x&#125;,
     *     &#123;@code x.equals(null)&#125; should return &#123;@code false&#125;.
     * &lt;&#x2F;ul&gt;
     * &lt;p&gt;
     * The &#123;@code equals&#125; method for class &#123;@code Object&#125; implements
     * the most discriminating possible equivalence relation on objects;
     * that is, for any non-null reference values &#123;@code x&#125; and
     * &#123;@code y&#125;, this method returns &#123;@code true&#125; if and only
     * if &#123;@code x&#125; and &#123;@code y&#125; refer to the same object
     * (&#123;@code x &#x3D;&#x3D; y&#125; has the value &#123;@code true&#125;).
     * &lt;p&gt;
     * Note that it is generally necessary to override the &#123;@code hashCode&#125;
     * method whenever this method is overridden, so as to maintain the
     * general contract for the &#123;@code hashCode&#125; method, which states
     * that equal objects must have equal hash codes.
     *
     * @param   obj   the reference object with which to compare.
     * @return  &#123;@code true&#125; if this object is the same as the obj
     *          argument; &#123;@code false&#125; otherwise.
     * @see     #hashCode()
     * @see     java.util.HashMap
     *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>reflexive 自反性  对于任何非空引用变量x，x.equals(x) 一定是true</li>
<li>symmetric 对称性 对于任何非空引用变量x和y，如果x.equals(y) 为true，那么y.equals(x) 也为true</li>
<li>transitive 传递性 对于任何非空引用变量x，y，z 。如果x.equals(y) 为true，且y.equals(z)也为true，那么x.equals(z)也是true</li>
<li>consistent 一致性 对于任何非空引用变量x，y。x和y的数据类型要一致。如果类型不一致就直接false</li>
<li>not null  非空性 对于任何非空的引用变量和null的比较都是false。</li>
</ul>
<h2 id="4-static"><a href="#4-static" class="headerlink" title="4.static"></a>4.static</h2><ul>
<li><p>静态只能直接访问静态，不可以直接访问非静态。想要在静态的范围内访问非静态内容，必须通过对象.非静态内容访问。</p>
</li>
<li><p>静态全局唯一</p>
</li>
<li><p>静态优先加载</p>
</li>
<li><ul>
<li>和构造相比，比构造方法先执行！</li>
</ul>
</li>
</ul>
<h2 id="5-类加载"><a href="#5-类加载" class="headerlink" title="5.类加载"></a>5.类加载</h2><h3 id="5-1类加载过程"><a href="#5-1类加载过程" class="headerlink" title="5.1类加载过程"></a>5.1类加载过程</h3><p>写了一个源码文件，编译后得到字节码文件，通过ClassLoader 类加载器 加载到JVM中。类加载需要经历以下几个步骤</p>
<p><img src="/2022/11/26/javase/classInit1.png"></p>
<p><img src="/2022/11/26/javase/classInit2.png"></p>
<p>总结：为什么静态的优先于构造执行，类加载执行的顺序分为3个阶段：加载，链接和初始化。静态的内容内存空间的开辟是在链接的准备阶段完成的并赋予类类型的默认值。然后链接完成进入初始化阶段才会执行构造方法。所以我们说静态的优先于构造加载。</p>
<p>需要注意的一个细节：静态的变量要被赋值两次，链接准备阶段赋予类型的默认值，初始化阶段赋予实际的值</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo05&#123;
    static int i &#x3D; 10;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<p>链接阶段开辟内存空间并起名为i，并赋予类型的默认值0，然后链接结束进入初始化阶段。会对i做二次赋值，赋予实际的值10。</p>
<h3 id="5-2ClassLoader分为3种"><a href="#5-2ClassLoader分为3种" class="headerlink" title="5.2ClassLoader分为3种"></a>5.2ClassLoader分为3种</h3><p><img src="/2022/11/26/javase/classInit3.png"></p>
<ul>
<li><p>Bootstrap Class Loader   加载 C:\Program Files\Java\jdk1.8.0_341\jre\lib\rt.jar</p>
</li>
<li><p>Extension Class Loader   加载C:\Program Files\Java\jdk1.8.0_341\jre\lib\ext 目录下所有的Jar</p>
</li>
<li><ul>
<li>extension 扩展的意思</li>
</ul>
</li>
<li><p>System Class Loader      加载ClassPath下的所有class。我们使用都是编译器，源码是写在source root下（src）</p>
</li>
</ul>
<h2 id="6-IO"><a href="#6-IO" class="headerlink" title="6.IO"></a>6.IO</h2><h3 id="6-1-IO的概念"><a href="#6-1-IO的概念" class="headerlink" title="6.1 IO的概念"></a>6.1 IO的概念</h3><p>IO 是Input 和 Output的缩写，表示的是输入和输出，Input代表输入（读），Output代表输出（写）。中文被叫做流。</p>
<p>可以用到IO的场景有如下几个：</p>
<ul>
<li>文件导出-》文件下载</li>
<li>简历上传-》文件上传</li>
<li>根据Excel批量导入</li>
</ul>
<h3 id="6-2-IO的分类"><a href="#6-2-IO的分类" class="headerlink" title="6.2 IO的分类"></a>6.2 IO的分类</h3><p>IO有很多种，我们以内存作为参照为，把IO分为两类</p>
<ul>
<li>输入流：流向内存的。  读取CSV文件中的数据是输入流，数据从CSV文件流向内存</li>
<li>输出流：从内存流出的。生成租赁记录，要持久化（写入文件中）保存，从内存流出，流向硬盘。所以是输出流。</li>
</ul>
<p>根据是否有直接操作数据源，IO又可以分为两类</p>
<ul>
<li>节点流：直接操作目标文件</li>
<li>处理流：对节点流或者处理流做包装。（涉及到装饰设计模式）</li>
</ul>
<p>根据最小单位IO又可以分为两类</p>
<ul>
<li>字节 -》 最小单位是字节：byte</li>
<li>字符 -》 最小单位是字符：char</li>
</ul>
<h3 id="6-3-字节"><a href="#6-3-字节" class="headerlink" title="6.3 字节"></a>6.3 字节</h3><p>字节流有两个根类：InputStream（输入流），OutputStream（流）。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class InputStream implements Closeable &#123;&#125;
public abstract class OutputStream implements Closeable, Flushable &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>无论是InputStream还是OutputStream都被 abstract 修饰，表示为抽象。被abstract修饰的类叫做抽象类，抽象类是不可以实例化的（创建对象），简单说这两个类我们无法构建实例来使用，我们能够使用的只能是它们的子类。</p>
<p>凡是字节流都会以InputStream或者OutputStream结尾。</p>
<h4 id="1-3-1-字节输入"><a href="#1-3-1-字节输入" class="headerlink" title="1.3.1 字节输入"></a>1.3.1 字节输入</h4><p>读</p>
<p>读取文件的流程是非常固定的</p>
<ol>
<li><p>提供文件的路径或者File对象</p>
</li>
<li><p>根据路径或者File对象构建输入流对象-》FileInputStream</p>
</li>
<li><p>提供三个工具变量</p>
</li>
<li><ol>
<li>int length = 0; 用于记录每次读取的字节数</li>
<li>byte[] buffer = new byte[]  缓存区，用来保存每次读取的内容</li>
<li>StringBuilder SBuild = new StringBuilder 一个可变的字符串，用于拼接每次读取的内容</li>
</ol>
</li>
<li><p>利用read的返回值不为-1代表没有读取到文件末尾来构建循环条件，使用while搭建循环</p>
</li>
<li><p>将每次读取的内容转变成String，并拼接到sBuilder中</p>
</li>
<li><p>循环结束，读取完成！</p>
</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class Demo01 &#123;
    public static void main(String[] args) &#123;
        String path &#x3D; &quot;c:\\001.txt&quot;;
        File file &#x3D; new File(path);
        &#x2F;&#x2F;-- 验证下这个文件的路径
        String absolutePath &#x3D; file.getAbsolutePath();
        System.out.println(absolutePath);
        &#x2F;&#x2F;-- 验证下这个文件是否存在
        System.out.println(file.exists());

        &#x2F;&#x2F;-- 文件输入流，最常用的字节输入流
        &#x2F;&#x2F;-- 接收两种类型的参数：File（文件对象），String （文件路径）
        &#x2F;&#x2F;-- 底层存在构造方法调用问题。this(path !&#x3D; null ? new File(path) : path)
        &#x2F;&#x2F;-- 所以我们直接给String类型的路径是完全OK的！
        &#x2F;&#x2F;-- try() 是JDK1.8新特性。小括号里面的必须是支持自动关闭的资源。JVM会自动帮我们关闭资源！
        try(FileInputStream fis &#x3D; new FileInputStream(path);)&#123;
            byte[] buffer &#x3D; new byte[1024];
            &#x2F;&#x2F;-- 返回值是-1到Integer.MAX_VALUE之间的顺序，代表实际读取的字节数！如果是-1则表示读取到文件末尾！
            int length &#x3D; fis.read(buffer);
            System.out.println(new String(buffer,0,length));
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class Demo02 &#123;
    public static void main(String[] args) &#123;
        String path &#x3D; &quot;c:\\001.txt&quot;;
        try(FileInputStream fis &#x3D; new FileInputStream(path);)&#123;
            &#x2F;&#x2F;UTF-8编码一个中文占3个字节！
            byte[] buffer &#x3D; new byte[3];
            &#x2F;&#x2F;--  当buffer不够大时，我们只能选择多次读取。多次读取循环构建循环。循环的核心：循环条件(本质就是一个布尔值)
            &#x2F;&#x2F;--  read方法有返回值，返回的是读取的字节数，如果读取到文件的末尾将会返回-1.
            &#x2F;&#x2F;--  如果读取到-1，表示读取到文件末尾，循环可以停止了！
            &#x2F;&#x2F;--  我们不确定循环次数，所以使用while循环
            int length &#x3D; 0;
            &#x2F;&#x2F;-- 和String一样都代表字符串。String是不可变的，StringBuilder是可变的。
            StringBuilder sBuilder &#x3D; new StringBuilder();
            &#x2F;&#x2F;-- !&#x3D; 从左向右算，先算-1，再算右边整体（）
            &#x2F;&#x2F;-- ()里面是赋值符号，赋值有从右向左算，即fis.read(buffer)得到返回值后，赋值给length
            &#x2F;&#x2F;-- 再拿length和-1做比较！
            while (-1 !&#x3D; (length &#x3D; fis.read(buffer)))&#123;
                String str &#x3D; new String(buffer,0,length);
                sBuilder.append(str);
            &#125;
            System.out.println(sBuilder.toString());
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.UnsupportedEncodingException;
import java.util.Arrays;

public class Demo03 &#123;
    public static void main(String[] args) throws UnsupportedEncodingException &#123;

        String str &#x3D; &quot;今&quot;;
        &#x2F;&#x2F;-- 将字符串的内容按照指定编码来构建字节数组
        byte[] bytes &#x3D; str.getBytes(&quot;UTF-8&quot;);
        System.out.println(Arrays.toString(bytes));
        byte[] b &#x3D; &#123;-28,-69&#125;;
        String s &#x3D; new String(b,&quot;UTF-8&quot;);
        System.out.println(s);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="1-3-2-字节输出"><a href="#1-3-2-字节输出" class="headerlink" title="1.3.2 字节输出"></a>1.3.2 字节输出</h4><p>写</p>
<p>写文件的思路和读取的思路非常的类似也分为以下几个步骤</p>
<ol>
<li>提供文件的路径或者指向文件的File对象</li>
<li>根据路径或者File对象构建输出流对象：FileOutputStream</li>
<li>调用 FileOutputStream的API方法来进行写文件：只能写字节数组！</li>
<li>关闭流。</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class Demo04 &#123;

    public static void main(String[] args) &#123;
        &#x2F;&#x2F;1.提供文件的路径
        String path &#x3D; &quot;c:\\001.txt&quot;;
        &#x2F;&#x2F;2.构建输出流对象
        try(FileOutputStream fos &#x3D; new FileOutputStream(path,true);)&#123;
            fos.write(&quot;外面下雨了吗？天好阴！&quot;.getBytes(&quot;UTF-8&quot;));
            fos.write(&quot;\r\n&quot;.getBytes(&quot;UTF-8&quot;));
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="1-3-3-字节流案例：拷贝图片"><a href="#1-3-3-字节流案例：拷贝图片" class="headerlink" title="1.3.3 字节流案例：拷贝图片"></a>1.3.3 字节流案例：拷贝图片</h4><p>因为字节流读写的都是字节，所以它对文本类比较乏力，字节流一般用于媒体，图片这一类的资源拷贝！</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class Demo05 &#123;
    public static void main(String[] args)  &#123;
        &#x2F;&#x2F; 在 E盘有壁纸： E:\壁纸\鬼刀.jpg （读），现在需要拷贝到桌面 C:\Users\Administrator\Desktop（写）
        &#x2F;&#x2F;-- 要求用代码实现！！

        &#x2F;&#x2F;-- 1.提供地址
        String resource &#x3D; &quot;E:\\壁纸\\鬼刀.jpg&quot;;
        String target &#x3D; &quot;C:\\Users\\Administrator\\Desktop\\鬼刀.jpg&quot;;
        &#x2F;&#x2F;-- 2.提供两个变量：length，buffer，
        int length &#x3D; 0;
        byte[] buffer &#x3D; new byte[1024];
        &#x2F;&#x2F;-- 3.根据路径创建流
        try(FileInputStream fis &#x3D; new FileInputStream(resource);
                FileOutputStream fos &#x3D; new FileOutputStream(target);)&#123;
            while (-1 !&#x3D; (length &#x3D; fis.read(buffer)))&#123;
                fos.write(buffer,0,length);
            &#125;
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-4-字符"><a href="#1-4-字符" class="headerlink" title="1.4 字符"></a>1.4 字符</h3><p>Tips：写法和字节流的写法基本一致，只是把字节流的类替换成字符流的类，把字节数组替换成字符数组。</p>
<p>字符流也有两个根：Reader（读），Writer（写）。所有的字符流都会以Reader你或者Writer结尾。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Reader implements Readable, Closeable &#123;&#125;
public abstract class Writer implements Appendable, Closeable, Flushable &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="1-4-1-字符输入"><a href="#1-4-1-字符输入" class="headerlink" title="1.4.1 字符输入"></a>1.4.1 字符输入</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Demo06 &#123;
    public static void main(String[] args) &#123;
        &#x2F;*
            字节变字符
                1.字节数组-》字符数组
                2.字节流类-》字符流类
         *&#x2F;
        String path &#x3D; &quot;c:\\001.txt&quot;;
        try(FileReader fis &#x3D; new FileReader(path);)&#123;
            char[] buffer &#x3D; new char[1024];
            int length &#x3D; 0;
            StringBuilder sBuilder &#x3D; new StringBuilder();
            while (-1 !&#x3D; (length &#x3D; fis.read(buffer)))&#123;
                String str &#x3D; new String(buffer,0,length);
                sBuilder.append(str);
            &#125;
            System.out.println(sBuilder.toString());
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="1-4-2-字符输出"><a href="#1-4-2-字符输出" class="headerlink" title="1.4.2 字符输出"></a>1.4.2 字符输出</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;

public class Demo07 &#123;

    public static void main(String[] args) &#123;
        &#x2F;&#x2F;1.提供文件的路径
        String path &#x3D; &quot;c:\\001.txt&quot;;
        &#x2F;&#x2F;2.构建输出流对象
        try(FileWriter fw &#x3D; new FileWriter(path,false);)&#123;
            fw.write(&quot;蓝蓝的天！&quot;);
            &#x2F;&#x2F;fw.flush();
            &#x2F;&#x2F;-- 在字符流关闭时，会自动flush。所以flush和close二选一，一般推荐选择close
            &#x2F;&#x2F;-- 我们使用的是try() 所以它会自动帮们调用close方法。
            &#x2F;&#x2F;fw.close();
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>字符输出流和字节输出流不太一样地方在于：字符流需要flush，而字节流不需要！</p>
<h3 id="1-5-缓冲"><a href="#1-5-缓冲" class="headerlink" title="1.5 缓冲"></a>1.5 缓冲</h3><p>字符流是对字节流做包装的，缓冲流就是对字符流再次包装。字符流每次读取只能读取1个字符，我们觉得效率还是低了，希望可以更快速的读取，所以在字符流的基础上设计了缓冲流。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BufferedReader extends Reader &#123;&#125;
public class BufferedWriter extends Writer &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>缓冲流本质仍然是字符流！在我们使用缓冲流时，就有一个典型的套路：套娃</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Demo09 &#123;

    public static void main(String[] args) &#123;
        &#x2F;&#x2F;--  提供路径！
        String path &#x3D; &quot;c:\\001.txt&quot;;
        &#x2F;&#x2F;-- 提供Reader
        try(FileReader fr &#x3D; new FileReader(path);
            &#x2F;&#x2F;-- 最终的目标：BufferedReader 它的构建需要一个Reader
            BufferedReader br &#x3D; new BufferedReader(fr);)&#123;

            &#x2F;&#x2F;-- 文件的末尾会有EOF标识： End Of File
            &#x2F;&#x2F;-- readLine会返回读取的一行内容。如果读取到EOF标识会返回null。
            &#x2F;&#x2F;-- 最后一行的读取，需要2次进行。首先读取到EOF，会停下来，把这一行 EOF之前的内容全部返回。
            &#x2F;&#x2F;-- 然后再返回一次EOF  仿照上午利用-1的方式来构建一个循环
            String line &#x3D; &quot;&quot;;
            StringBuilder sb &#x3D; new StringBuilder();
            while (null !&#x3D; (line &#x3D; br.readLine()))&#123;
                sb.append(line);
            &#125;
            System.out.println(sb.toString());
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
import java.io.*;

public class Demo10 &#123;

    public static void main(String[] args) &#123;
        &#x2F;&#x2F;--  提供路径！
        String path &#x3D; &quot;c:\\001.txt&quot;;
        try(FileWriter fw &#x3D; new FileWriter(path);
             BufferedWriter bw &#x3D; new BufferedWriter(fw);)&#123;
            bw.write(&quot;格林豪泰！&quot;);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-6-对象数据"><a href="#1-6-对象数据" class="headerlink" title="1.6 对象数据"></a>1.6 对象数据</h3><h4 id="1-6-1-对象流"><a href="#1-6-1-对象流" class="headerlink" title="1.6.1 对象流"></a>1.6.1 对象流</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.*;

public class Demo14 &#123;
    public static void main(String[] args) &#123;
        String path &#x3D; &quot;c:\\001.txt&quot;;

        User user &#x3D; new User();
        user.setId(1);
        user.setName(&quot;张三&quot;);
        user.setGender(&quot;男&quot;);
        user.setAge(10);

        Demo14 d &#x3D; new Demo14();
        &#x2F;&#x2F;d.writeToFile(path,user);

        User u &#x3D; (User) d.readFromFile(path);
        System.out.println(u);

    &#125;

    public Object readFromFile(String path)&#123;
        try(FileInputStream fis &#x3D; new FileInputStream(path);
        ObjectInputStream ois &#x3D; new ObjectInputStream(fis);)&#123;
            Object o &#x3D; ois.readObject();
            return o;
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    public void  writeToFile(String path,User user)&#123;
        try(FileOutputStream fos &#x3D; new FileOutputStream(path);
            ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);)&#123;
            oos.writeObject(user);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;

class User implements Serializable &#123;
    public static final long serialVersionUID &#x3D; 1L;

    private Integer id;
    private String name;
    private Integer age;
    private String gender;

    public Integer getId() &#123;
        return id;
    &#125;

    public void setId(Integer id) &#123;
        this.id &#x3D; id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name &#x3D; name;
    &#125;

    public Integer getAge() &#123;
        return age;
    &#125;

    public void setAge(Integer age) &#123;
        this.age &#x3D; age;
    &#125;

    public String getGender() &#123;
        return gender;
    &#125;

    public void setGender(String gender) &#123;
        this.gender &#x3D; gender;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
                &quot;id&#x3D;&quot; + id +
                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age&#x3D;&quot; + age +
                &quot;, gender&#x3D;&#39;&quot; + gender + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="1-6-2-数据流"><a href="#1-6-2-数据流" class="headerlink" title="1.6.2 数据流"></a>1.6.2 数据流</h4><p>数据流和对象流的功能是非常相似的，唯一的区别就在于没有读写对象的能力。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.*;

public class Demo15 &#123;
    public static void main(String[] args) &#123;
        String path &#x3D; &quot;c:\\001.txt&quot;;
        &#x2F;&#x2F;writeToFile(path);

        try(FileInputStream fis &#x3D; new FileInputStream(path);
        DataInputStream dis &#x3D; new DataInputStream(fis))&#123;
            String s &#x3D; dis.readUTF();
            System.out.println(s);
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    private static void writeToFile(String path) &#123;
        try(FileOutputStream fos &#x3D; new FileOutputStream(path);
            DataOutputStream dos &#x3D; new DataOutputStream(fos);)&#123;
            dos.writeUTF(&quot;老乡鸡 干净卫生 品质放心&quot;);
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="1-8-读小说提取目录章节"><a href="#1-8-读小说提取目录章节" class="headerlink" title="1.8 读小说提取目录章节"></a>1.8 读小说提取目录章节</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class Demo11 &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F;-- 需求1：显示所有的章节目录
        &#x2F;&#x2F;-- 需求2：根据输入的章节进行跳转
        String reg &#x3D; &quot;第.+[回章篇].&#123;0,18&#125;&quot;;
        &#x2F;*
            1.使用BufferedReader来读取文件 （因为要一行一行读）
            2.判断所读取的每一行是否匹配正则，匹配保存，不匹配不保存
            3.需要一个变长的容器：ArrayList
         *&#x2F;
        String path &#x3D; &quot;红楼梦.txt&quot;;
        ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();
        ArrayList&lt;String&gt; chapterContentList &#x3D; new ArrayList&lt;&gt;();
        Long l &#x3D; 0L;
        try (FileReader fr &#x3D; new FileReader(path);
             BufferedReader br &#x3D; new BufferedReader(fr);) &#123;
            String content &#x3D; &quot;&quot;;
            StringBuilder sBuilder &#x3D; new StringBuilder();
            while (null !&#x3D; (content &#x3D; br.readLine())) &#123;
                if (content.matches(reg)) &#123;
                    list.add(content);
                    &#x2F;&#x2F;-- 下一次遇到章节时，sBuilder中保存的应该是上一个章节的全部内容
                    &#x2F;&#x2F;-- 把内容写入到第二个集合中，并清空sBuilder来记录新章节的内容！
                    chapterContentList.add( sBuilder.toString());
                    sBuilder.delete(0,sBuilder.length());
                &#125;
                sBuilder.append(content);
                sBuilder.append(&quot;\r\n&quot;);
            &#125;
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;

        for (String chapter : list) &#123;
            System.out.println(chapter);
        &#125;
        System.out.println(&quot;要查看的章节&quot;);
        Scanner scan &#x3D; new Scanner(System.in);
        int i &#x3D; scan.nextInt();

        String content &#x3D; chapterContentList.get(i);
        System.out.println(content);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-9-序列化"><a href="#1-9-序列化" class="headerlink" title="1.9 序列化"></a>1.9 序列化</h3><p><img src="/2022/11/26/javase/%E5%BA%8F%E5%88%97%E5%8C%96.png"></p>
<p>当我们尝试把一个对象写入文件时（使用对象流），抛出异常：没有序列化异常！Java的序列化有两种（基本只用一种）</p>
<ul>
<li>自动序列化</li>
<li>手工序列化</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;-- 只要实现了这个接口就被认为自动序列化完成了！
class User implements Serializable &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>当实现序列化接口时，需要提供要一个序列化ID，如果没有提供写文件不会有问题，但是读文件一定会报错：</p>
<p><img src="/2022/11/26/javase/%E5%BA%8F%E5%88%97%E5%8C%96Exception.png"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.*;

public class Demo14 &#123;
    public static void main(String[] args) &#123;
        String path &#x3D; &quot;c:\\001.txt&quot;;

        User user &#x3D; new User();
        user.setId(1);
        user.setName(&quot;张三&quot;);
        user.setGender(&quot;男&quot;);
        user.setAge(10);

        Demo14 d &#x3D; new Demo14();
        &#x2F;&#x2F;d.writeToFile(path,user);

        User u &#x3D; (User) d.readFromFile(path);
        System.out.println(u);

    &#125;

    public Object readFromFile(String path)&#123;
        try(FileInputStream fis &#x3D; new FileInputStream(path);
        ObjectInputStream ois &#x3D; new ObjectInputStream(fis);)&#123;
            Object o &#x3D; ois.readObject();
            return o;
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    public void  writeToFile(String path,User user)&#123;
        try(FileOutputStream fos &#x3D; new FileOutputStream(path);
            ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);)&#123;
            oos.writeObject(user);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;

class User implements Serializable &#123;
    public static final long serialVersionUID &#x3D; 1L;

    private Integer id;
    private String name;
    private Integer age;
    private String gender;

    public Integer getId() &#123;
        return id;
    &#125;

    public void setId(Integer id) &#123;
        this.id &#x3D; id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name &#x3D; name;
    &#125;

    public Integer getAge() &#123;
        return age;
    &#125;

    public void setAge(Integer age) &#123;
        this.age &#x3D; age;
    &#125;

    public String getGender() &#123;
        return gender;
    &#125;

    public void setGender(String gender) &#123;
        this.gender &#x3D; gender;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
                &quot;id&#x3D;&quot; + id +
                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age&#x3D;&quot; + age +
                &quot;, gender&#x3D;&#39;&quot; + gender + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对象流在读的时候极容易导致EOFException，所以很少会选择直接把对象写入文件。并且对象流写入文件后的内容，我们无法阅读，就导致基本不会有人选择用对象流来做存储！</p>
<p>所以对象流往往只是作为一个引子，用于引出序列化！</p>
<h3 id="1-10-正则表达式"><a href="#1-10-正则表达式" class="headerlink" title="1.10 正则表达式"></a>1.10 正则表达式</h3><h4 id="1-10-1-正则基础"><a href="#1-10-1-正则基础" class="headerlink" title="1.10.1 正则基础"></a>1.10.1 正则基础</h4><p>正则表达式本质就是一个字符串，它内容可以分为两种</p>
<ul>
<li>字面常量</li>
<li>具有特殊含义的表达式</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>任意一个字符</td>
<td></td>
</tr>
<tr>
<td>*</td>
<td>*所修饰的内容，至少出现0次或者重复出现N次</td>
<td>a*  表示a可以出现0次，或者n次</td>
</tr>
<tr>
<td>+</td>
<td>+所修饰的内容，至少出现1次或者重复出现N次</td>
<td>a+ 表示a至少出现1，或者出现n次</td>
</tr>
<tr>
<td>？</td>
<td>？所修饰的内容，至少出现0次或者至多出现1次</td>
<td>a？ 表示a至少出现0，或者最多出现1次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>{n,m}所修饰的内容可以出现n-m次~</td>
<td>a{1，3} 表示a可以出现1次，或者2次，或者3次。</td>
</tr>
<tr>
<td>[abcdef]</td>
<td>字符集合。匹配所包含的任意一个字符。</td>
<td>[abc]’可以匹配 “plain” 中的 ‘a’。</td>
</tr>
<tr>
<td>\d</td>
<td>只能匹配数字等价于 [0-9]</td>
<td></td>
</tr>
<tr>
<td>\D</td>
<td>可以匹配所有非数字内容</td>
<td></td>
</tr>
<tr>
<td>\s</td>
<td>匹配所有的空白符：等价于  [\r\n\t\f\v]</td>
<td></td>
</tr>
<tr>
<td>\S</td>
<td>匹配所有的非空白符，等价于 [^\r\n\t\f\v])</td>
<td></td>
</tr>
<tr>
<td>\w</td>
<td>matches any word character (equivalent to [a-zA-Z0-9_])</td>
<td></td>
</tr>
<tr>
<td>\W</td>
<td>matches any non-word character (equivalent to [^a-zA-Z0-9_])</td>
<td></td>
</tr>
<tr>
<td>^</td>
<td>以什么开头</td>
<td></td>
</tr>
<tr>
<td>$</td>
<td>以什么结尾</td>
<td></td>
</tr>
</tbody></table>
<h4 id="1-10-2-Java-操作正则"><a href="#1-10-2-Java-操作正则" class="headerlink" title="1.10.2 Java 操作正则"></a>1.10.2 Java 操作正则</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;

public class Demo12 &#123;
    public static void main(String[] args) &#123;
        Scanner scan &#x3D; new Scanner(System.in);
        System.out.println(&quot;请录入一个数字&quot;);
        String str &#x3D; scan.next();
        &#x2F;&#x2F;-- 声明一个正则
        String reg &#x3D; &quot;\\d+&quot;;
        boolean matches &#x3D; str.matches(reg);
        System.out.println(matches);
        if (matches)&#123;
            Integer i &#x3D; Integer.parseInt(str);
            System.out.println(i);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/2022/11/26/javase/java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Demo13 &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F;-- 创建一个正则对象，并定义了规则：\w+ 只允许出现a-zA-Z0-9_这几种符号 +表示至少1个，至多n个
        Pattern pattern &#x3D; Pattern.compile(&quot;^[A-Z]\\w&#123;7,15&#125;&quot;);
        Scanner scan &#x3D; new Scanner(System.in);
        &#x2F;&#x2F;-- 规则：密码必须大写字母开头，成分字母，数字，_三种 数量在8-16之间
        System.out.println(&quot;Enter Password&quot;);
        String pass &#x3D; scan.next();

        &#x2F;&#x2F;-- matcher 是匹配的意思  Matcher 可以认为是比较器！！
        Matcher matcher &#x3D; pattern.matcher(pass);
        &#x2F;&#x2F;-- matches() 匹配的方法。并得到结果boolean代表是否匹配
        boolean result &#x3D; matcher.matches();
        System.out.println(result);

    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-11-文件夹和文件的创建"><a href="#1-11-文件夹和文件的创建" class="headerlink" title="1.11 文件夹和文件的创建"></a>1.11 文件夹和文件的创建</h3><p>文件和文件夹的创建都需要File，它们是File所提供的API功能。分别对应两个API</p>
<ul>
<li>createNewFile() 创建任意格式的文件</li>
<li>mkdirs() 创建任意级的目录</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;
import java.io.IOException;

public class Demo16 &#123;
    public static void main(String[] args) &#123;
        File file &#x3D; new File(&quot;扫码连WIFI.txt&quot;);
        &#x2F;&#x2F;-- 输出绝对路径
        System.out.println(file.getAbsolutePath());
        &#x2F;&#x2F;-- 输出文件是否存在
        System.out.println(file.exists());
        &#x2F;&#x2F;-- 输出是不是一个 文件
        System.out.println(file.isFile());
        &#x2F;&#x2F;-- 输出是不是一个文件夹
        System.out.println(file.isDirectory());
        &#x2F;&#x2F;-- 获取文件的上级目录
        &#x2F;&#x2F;File parentFile &#x3D; file.getParentFile();
        &#x2F;&#x2F;-- 输出上级目录的路径
        &#x2F;&#x2F;System.out.println(parentFile.exists());

        &#x2F;&#x2F;--  创建文件
        try &#123;
            boolean newFile &#x3D; file.createNewFile();
            if (newFile)&#123;
                System.out.println(&quot;创建成功&quot;);
            &#125;else &#123;
                System.out.println(&quot;创建失败&quot;);
            &#125;
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;

        &#x2F;&#x2F;-- 创建文件夹
        File file2 &#x3D; new File(&quot;a&#x2F;b&#x2F;c&#x2F;d&quot;);
        file2.mkdirs();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-12-UUid"><a href="#1-12-UUid" class="headerlink" title="1.12 UUid"></a>1.12 UUid</h3><p>UUID是特殊的字符串，它是通过一些列的算法进行计算得到的，一台设备24小时不间断运行大约需要百年才会产生一个重复的！所以UUID可以认为是唯一的。它的写法是固定的</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.UUID;

public class Demo17 &#123;
    public static void main(String[] args) &#123;
        String str &#x3D; UUID.randomUUID().toString();
        &#x2F;&#x2F;-- 32位 + 4个-连接符 共36位
        System.out.println(str);
        &#x2F;&#x2F;-- 我们一般是不要连接符的
        str &#x3D; str.replace(&quot;-&quot;,&quot;&quot;).toUpperCase();
        System.out.println(str);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="7-集合"><a href="#7-集合" class="headerlink" title="7.集合"></a>7.集合</h2><h3 id="7-1-集合框架概述"><a href="#7-1-集合框架概述" class="headerlink" title="7.1 集合框架概述"></a>7.1 集合框架概述</h3><p>作为容器，我们有数组可以使用，但是使用的过程中有各种不顺心，JAVA 提供了一套全新的容器也就是 JAVA 集合框架。</p>
<p>JAVA 的集合提下分为两类</p>
<p>单列集合 （一个数据一个数据存储）–&gt;Collection</p>
<ul>
<li><p>List        </p>
<ul>
<li>ArrayList      动态数组</li>
<li>Stack                 栈</li>
<li>LinkedList      链表</li>
</ul>
</li>
<li><p>Set </p>
<ul>
<li><p>HashSet   （HashSet是用HashMap来存储数据的）                 </p>
</li>
<li><p>LinkedHashSet  </p>
</li>
<li><p>TreeSet</p>
</li>
</ul>
</li>
<li><p>Queue  </p>
<ul>
<li>PriorityQueue   优先队列</li>
<li>DequeQueue    双端队列</li>
</ul>
</li>
</ul>
<p>双列集合（同时存储两份数据）</p>
<ul>
<li>HashMap</li>
<li>LinkedHashMap</li>
<li>TreeMap</li>
<li>SortedMaped</li>
<li>HashTable </li>
</ul>
<p><img src="/2022/11/26/javase/%E9%9B%86%E5%90%88.png"></p>
<h3 id="7-2-Collection和Collections"><a href="#7-2-Collection和Collections" class="headerlink" title="7.2 Collection和Collections"></a>7.2 Collection和Collections</h3><h4 id="7-2-1-Collection概述"><a href="#7-2-1-Collection概述" class="headerlink" title="7.2.1 Collection概述"></a>7.2.1 Collection概述</h4><p>Collection 是单列集合的根接口，里面定义了单列集合的公共方法。而 Collections 是集合的工具类，里面提供了集合的一些常用API：查找，排序等。</p>
<p>老外在命名时有一些很奇怪的习惯：比如Arrays代表数组的工具类，Objects用于对Object中的方法进行补充，因为Object中的方法都没有对NULL做判断，所有容易导致空指针，而 Objects 针对一部分做了完善，所有Objects 可以认为是Object的工具类。</p>
<p>Collection中的API有以下几个，因为它是单列集合的根接口，所以，所有的单列集合都拥有它所声明的方法。</p>
<p>使用IDEA时，在类中使用快捷键： Alt + 7 可以显式类的内容。</p>
<p><img src="/2022/11/26/javase/Collection.png"></p>
<ul>
<li>parallelStream()  JDK1.8 新特性 获取流</li>
<li>containsAll(Collection&lt;?&gt;)  判断当前集合是否包含另外一个集合的全部内容</li>
<li>toArray(T[])  将集合转成数组，目标数组需要我们以参数的形势传递进来</li>
<li>toArray()将集合转成数组，数组的元素默认为Object</li>
<li>contains(Object)  判断是否包含指定的元素 </li>
<li>clear()  清空集合里面的所有元素</li>
<li>removeAll(Collection&lt;?&gt;) 移除自身所包含的其它集合全部元素</li>
<li>isEmpty()  判断集合是否为空。这个空不是null，而是集合中没有元素</li>
<li>stream()  JDK1.8 新特性 获取Stream流</li>
<li>remove(Object)   移除指定的元素（注意如果元素类型为Integer时，直接给1，默认为int）</li>
<li>addAll(Collection<E>) 把传入集合的全部元素加入到当前集合中</li>
<li>size()   返回当前集合的元素个数</li>
<li>iterator()   获取迭代器，用于遍历集合中的数据</li>
</ul>
<h4 id="7-2-2-练习"><a href="#7-2-2-练习" class="headerlink" title="7.2.2 练习"></a>7.2.2 练习</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;

public class Demo01 &#123;

    public static void main(String[] args) &#123;
        &#x2F;&#x2F;--  &lt;&gt; 表示为泛型，是JDK1.5才出来的
        &#x2F;&#x2F;-- 后面尖括号里的内容可以省略是JDK1.7时推出的新特性
        Collection&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();
        list.add(&quot;A&quot;);

        &#x2F;&#x2F;-- Arrays.asList(元素1，元素2，元素3，，，元素n)  将N个元素转换成List集合
        Collection&lt;String&gt; list1 &#x3D; Arrays.asList(&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;);

        list.addAll(list1);

        &#x2F;&#x2F;-- 使用迭代器遍历list
        Iterator&lt;String&gt; iterator &#x3D; list.iterator();
        &#x2F;&#x2F;-- hasNext 返回一个布尔值，表示是否有下一个元素 如果返回true则表示有！ 如果返回false则表示没有！
        while (iterator.hasNext())&#123;
            &#x2F;&#x2F;-- next实际把元素取出来！
            String next &#x3D; iterator.next();
            System.out.println(next);
        &#125;

        list.addAll(list1);

        &#x2F;&#x2F;--  List 支持元素重复
        System.out.println(list);


        &#x2F;&#x2F;--  remove 只能移除第一个匹配的，如果有重复多个，则只删除第一个。
        &#x2F;&#x2F;boolean flag &#x3D; list.remove(&quot;D&quot;);
        &#x2F;&#x2F;--  如果要删除全部则用removeAll   可以同时删除多个元素！
        boolean flag &#x3D; list.removeAll(Arrays.asList(&quot;D&quot;,&quot;E&quot;,&quot;F&quot;));
        if (flag) &#123;
            System.out.println(&quot;删除成功&quot;);
        &#125;else &#123;
            System.out.println(&quot;删除失败&quot;);
        &#125;

        System.out.println(list);


        Object[] array1 &#x3D; list.toArray();

        &#x2F;&#x2F;--可以变成具体的类型！
        String[] array &#x3D; new String[list.size()];
        list.toArray(array);


        &#x2F;&#x2F;-- 加强for 在JDK1.8之后是基于迭代器实现的！
        for (String s : array) &#123;
            System.out.println(s);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="7-3-内部类"><a href="#7-3-内部类" class="headerlink" title="7.3 内部类"></a>7.3 内部类</h3><h4 id="7-3-1-什么是内部类"><a href="#7-3-1-什么是内部类" class="headerlink" title="7.3.1 什么是内部类"></a>7.3.1 什么是内部类</h4><p>写在一个 class 内部的 class就被叫做内部类。</p>
<h4 id="7-3-2-内部类的分类"><a href="#7-3-2-内部类的分类" class="headerlink" title="7.3.2 内部类的分类"></a>7.3.2 内部类的分类</h4><p>根据位置和修饰符内部类可以分为四种，需要掌握的有两种</p>
<ul>
<li>成员内部类</li>
<li>静态成员内部类，简称静态内部类</li>
<li>局部内部类</li>
<li>匿名内部类*</li>
</ul>
<h4 id="7-3-3-内部类的写法"><a href="#7-3-3-内部类的写法" class="headerlink" title="7.3.3 内部类的写法"></a>7.3.3 内部类的写法</h4><h5 id="7-3-3-1-成员内部类"><a href="#7-3-3-1-成员内部类" class="headerlink" title="7.3.3.1 成员内部类"></a>7.3.3.1 成员内部类</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo02 &#123;
    private int i &#x3D; 20;
    private Demo02 d &#x3D; this;
    &#x2F;&#x2F;-- class A定义在class Demo02的内部，同时定义的位置是Demo02成员的位置，所有class A被叫做Demo02的成员内部类
    class A&#123;
        &#x2F;&#x2F;-- 类的定义：有一组实例，具备共性(特征（成员变量），行为（方法）)，把这些共性抽取出来组成了类
        &#x2F;&#x2F;-- 是先有人还是先有人类这个概念！
        &#x2F;&#x2F;-- 从抽象这个角度来说
        &#x2F;&#x2F;-- 先有一组对象,有共性，抽取出类！
        &#x2F;&#x2F;-- 当类多了,类和类之间也有共性，把这些共性继续抽象，抽取出父类！
        &#x2F;&#x2F;-- 父类也多了，父类代表的是某一类型的根，发现这些父类之间也有共性，没办法抽象。
        &#x2F;&#x2F;-- 父类和父类之间跨类型了，所以把共同的一部分定义成规范（接口）。接口之定义行为和类型无关！
        &#x2F;&#x2F;-- 在Java中接口是最顶级的抽象。父类是类型内部最高的抽象！
        private int i &#x3D; 10;
        &#x2F;&#x2F;-- JDK1.8以下（包含1.8）是不可以在成员内部类中使用static，如果要使用static至少需要JDK16
        &#x2F;&#x2F;private static int j;
        public A()&#123;

        &#125;
        public void method01()&#123;
            System.out.println(this.i);
            System.out.println(d.i);
        &#125;
        public void method02()&#123;&#125;
    &#125;

    public static void main(String[] args) &#123;
        Demo02 d &#x3D; new Demo02();
        System.out.println(d.i);

        A a &#x3D; d.new A();
        System.out.println(a.i);
        a.method01();
        a.method02();
    &#125;

    public void method01()&#123;
        A a &#x3D; new A();
        System.out.println(i);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="7-3-3-2-静态成员内部类"><a href="#7-3-3-2-静态成员内部类" class="headerlink" title="7.3.3.2 静态成员内部类"></a>7.3.3.2 静态成员内部类</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo03 &#123;
    private int i;
    private static int j;

    static class B&#123;
        private int i;
        private static int j;
        public static void main(String[] args) &#123;
            B b &#x3D; new B();
            System.out.println(b.i);
            System.out.println(j);
        &#125;

        public void method01()&#123;&#125;
        public static void method02()&#123;&#125;
    &#125;

    public void method01()&#123;
        B b &#x3D; new B();
    &#125;
    public static void method02()&#123;
        B b &#x3D; new B();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="7-3-3-3-局部内部类"><a href="#7-3-3-3-局部内部类" class="headerlink" title="7.3.3.3 局部内部类"></a>7.3.3.3 局部内部类</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo04 &#123;
    public static void main(String[] args) &#123;
        int i &#x3D; 10;
        class C&#123;

            public void method()&#123;
                &#x2F;&#x2F;-- 在JDK1.8以前，i声明时必须要给final关键字，在JDK1.8以后，可以省略final。
                &#x2F;&#x2F;-- 我们只是没有写final。不表示它不是final！
                System.out.println(i);
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>局部内部类最大的弊端在于作用域，它在方法内部声明，所以方法调用该内部类存在，方法调用结束，该内部类被销毁，我们甚至无法在方法外构建该内部类的实例。内部类C的所有使用都局限在定义它的方法内部。</p>
<h5 id="7-3-3-4-匿名内部类"><a href="#7-3-3-4-匿名内部类" class="headerlink" title="7.3.3.4 匿名内部类"></a>7.3.3.4 匿名内部类</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;
import java.util.Comparator;

public class Demo05 &#123;

    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();
        list.sort(new Comparator&lt;String&gt;() &#123;
            @Override
            public int compare(String o1, String o2) &#123;
                return 0;
            &#125;
        &#125;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Comparator是一个接口，接口是不可以被实例化的，在JDK1.8之前接口中只能声明方法，声明方法是没有方法体，所以假设我们可以构建接口的实例，在执行方法时也没东西可以执行。所以接口是不可以实例化的（抽象类也是这个道理）</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Comparator&lt;T&gt; &#123;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>得到了Comparator的实现类的对象，只是这个实现类没有名字，所以被叫做匿名类，又因为是写在Demo05的内部，所有被叫做 匿名内部类。</p>
<p>通过该匿名类的实例无法调用这些特有方法。因为这个匿名类是没有名字的，所以在声明实例时一定是使用多态的方式来声明：父类指向子类，或者接口指向实现类。即左右两边的数据类型不等价，运行时只能使用左边声明过的方法，所以无法使用我们在匿名类中定义的特有发方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;
import java.util.Comparator;

public class Demo05 &#123;

    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();
        &#x2F;&#x2F;-- 内部类的字节码文件命名规则：外部类名$内部类名
        Comparator&lt;String&gt; c &#x3D; new Comparator&lt;String&gt;() &#123;

            @Override
            public int compare(String o1, String o2) &#123;
                return 0;
            &#125;
        &#125;;

        list.sort(c);
    &#125;

    class C&#123;&#125;
    static class D&#123;&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>c 所代表的匿名内部类实例，只能使用Comparator中声明过的方法！</p>
<h4 id="7-3-4-内部类的作用"><a href="#7-3-4-内部类的作用" class="headerlink" title="7.3.4 内部类的作用"></a>7.3.4 内部类的作用</h4><p>为什么要有内部类，为了补充继承关系。JAVA的继承针对 class 来说是单继承，我们又想扩展功能，又不想使用继承关系，我们可以使用内部类来解决这个问题。我们通过内部类来实现出多继承的效果。</p>
<h3 id="7-4-Lambda表达式"><a href="#7-4-Lambda表达式" class="headerlink" title="7.4 Lambda表达式"></a>7.4 Lambda表达式</h3><p>Lambda表达式是C++的内容，是JDK1.8引入的新特性，体现出语法大兼容趋势。目的是简化匿名内部类的写法。想要使用Lambda前提是函数式接口：（FunctionalInterface）。只有一个抽象方法的接口叫做函数式接口，</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo06 &#123;

    interface I1&#123;
        void method01();
    &#125;

    public static void main(String[] args) &#123;
        &#x2F;&#x2F;-- 大括号代表类体，一个类实现了I1这个接口，因为这个类没有名字，所有叫做匿名类，又因为是在内部，所有叫做匿名内部类
        I1 i1 &#x3D; new I1() &#123;
            @Override
            public void method01() &#123;
                System.out.println(&quot;this is override&quot;);
            &#125;
        &#125;;

        i1.method01();
        &#x2F;&#x2F;-- 接口中只有一个抽象方法，我们提供的实现类，只需要对唯一的一个抽象方法进行重写
        &#x2F;&#x2F;-- 既然是唯一的一个，那么方法名确认了！那么我们唯一需要操心的只有参数列表。
        &#x2F;&#x2F;-- 所以可以直接省略new 构造方法这个过程，直接写方法。又方法名是确认的，所有省略方法名，只写()
        &#x2F;&#x2F;-- 用-&gt; 来指向方法体，如果方法体中只有一句话，那么大括号也可以省略。
        I1 i2 &#x3D; () -&gt; System.out.println(&quot;this is lambda&quot;);
        i2.method01();
    &#125;
&#125;
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo07 &#123;

    &#x2F;&#x2F;-- 加注解的目的是防止编译器发神经。有时候遇到只有一个抽象方法的接口，不识别为函数式接口。所以加注解起强调作用
    @FunctionalInterface
    interface I1 &#123;
        void method01();
    &#125;
    @FunctionalInterface
    interface I2 &#123;
        void method02(int i);
    &#125;
    @FunctionalInterface
    interface I3 &#123;
        void method03(int i, int j);
    &#125;
    @FunctionalInterface
    interface I4 &#123;
        void method04(int i, String str);
    &#125;
    @FunctionalInterface
    interface I5 &#123;
        int method05();
    &#125;
    @FunctionalInterface
    interface I6 &#123;
        int method06(int i);
    &#125;

    public  void testI1()&#123;
        &#x2F;&#x2F;-- 写法一 ：匿名内部类
        I1 i1 &#x3D; new I1() &#123;
            @Override
            public void method01() &#123;
                System.out.println(&quot;this is i1&quot;);
            &#125;
        &#125;;
        &#x2F;&#x2F;i1.method01();

        I1 i11 &#x3D; new I1() &#123;
            @Override
            public void method01() &#123;
                for (int i &#x3D; 0; i &lt; 10; i++) &#123;
                    System.out.println(i);
                &#125;
            &#125;
        &#125;;
        &#x2F;&#x2F;i11.method01();
        &#x2F;&#x2F;-- 写法二 ：Lambda
        I1 i &#x3D; () -&gt;  System.out.println(&quot;this is i1 lambda&quot;);
        i.method01();

        I1 j &#x3D; () -&gt; &#123;
            for (int k &#x3D; 0; k &lt; 10; k++) &#123;
                System.out.println(k);
            &#125;
        &#125;;
        j.method01();


    &#125;
    public  void testI2()&#123;
        &#x2F;&#x2F;-- 写法一 ：匿名内部类
        I2 i2 &#x3D; new I2() &#123;
            @Override
            public void method02(int i) &#123;
                System.out.println(i + 1);
            &#125;
        &#125;;
        i2.method02(3);
        &#x2F;&#x2F;-- 写法二 ：Lambda
        I2 i21 &#x3D; (int i)-&gt; &#123;System.out.println(i+2);&#125;;
        i21.method02(5);

        I2 i22 &#x3D; (i) -&gt; System.out.println(i +3);
        i22.method02(7);

        I2 i23 &#x3D; i -&gt; System.out.println(i + 9);
        i23.method02(11);

        I2 i24 &#x3D; System.out::println;
        i24.method02(100);
    &#125;
    public  void testI3()&#123;
        &#x2F;&#x2F;-- 写法一 ：匿名内部类
        I3 i3 &#x3D; new I3() &#123;
            @Override
            public void method03(int i, int j) &#123;
                System.out.println(i + j);
            &#125;
        &#125;;
        i3.method03(3,3);
        &#x2F;&#x2F;-- 写法二 ：Lambda
        I3 i31 &#x3D; (i,j) -&gt; System.out.println(i+j);
        I3 i32 &#x3D; (a,b) -&gt; &#123;
            for (int k &#x3D; a ; k &lt; b ; k ++)&#123;
                System.out.println(k);
            &#125;
        &#125;;
        i32.method03(1,10);
    &#125;
    public  void testI4()&#123;
        &#x2F;&#x2F;-- 写法一 ：匿名内部类
        I4 i4 &#x3D; new I4() &#123;
            @Override
            public void method04(int i, String str) &#123;
                System.out.println(i);
                System.out.println(str);
            &#125;
        &#125;;
        i4.method04(14,&quot;没有情人的情人节&quot;);
        &#x2F;&#x2F;-- 写法二 ：Lambda
        I4 i41 &#x3D; (a,b) -&gt; System.out.println(a + &quot;\n&quot; + b);
    &#125;
    public  void testI5()&#123;
        &#x2F;&#x2F;-- 写法一 ：匿名内部类
        I5 i5 &#x3D; new I5() &#123;
            @Override
            public int method05() &#123;
                return -1;
            &#125;
        &#125;;
        i5.method05();
        &#x2F;&#x2F;-- 写法二 ：Lambda
        I5 i51 &#x3D; () -&gt; &#123;return  11;&#125;;
        &#x2F;&#x2F;-- 相当于省略了大括号，省略了return关键字 箭头后面所跟的就是返回的值
        I5 i52 &#x3D; () -&gt;  22;
        int i &#x3D; i52.method05();
        System.out.println(i);
    &#125;
    public  void testI6()&#123;
        &#x2F;&#x2F;-- 写法一 ：匿名内部类
        I6 i6 &#x3D; new I6() &#123;
            @Override
            public int method06(int i) &#123;
                return i +3;
            &#125;
        &#125;;
        int i1 &#x3D; i6.method06(11);
        System.out.println(i1);
        &#x2F;&#x2F;-- 写法二 ：Lambda
        I6 i61 &#x3D; (i) -&gt; i+3;
        int i2 &#x3D; i61.method06(13);
        System.out.println(i2);
    &#125;

    public static void main(String[] args) &#123;
        Demo07 d &#x3D; new Demo07();
        d.testI6();
    &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="7-5-Stream-流"><a href="#7-5-Stream-流" class="headerlink" title="7.5 Stream 流"></a>7.5 Stream 流</h3><h4 id="7-5-1-流介绍"><a href="#7-5-1-流介绍" class="headerlink" title="7.5.1 流介绍"></a>7.5.1 流介绍</h4><ul>
<li><p>stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果；</p>
</li>
<li><p>stream不会改变数据源，通常情况下会产生一个新的集合；</p>
</li>
<li><p>stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。对stream操作分为终端操作和中间操作，那么这两者分别代表什么呢？</p>
</li>
<li><ul>
<li>终端操作：会消费流，这种操作会产生一个结果的，如果一个流被消费过了，那它就不能被重用的。</li>
<li>中间操作：中间操作会产生另一个流。因此中间操作可以用来创建执行一系列动作的管道。一个特别需要注意的点是:中间操作不是立即发生的。相反，当在中间操作创建的新流上执行完终端操作后，中间操作指定的操作才会发生。所以中间操作是延迟发生的，中间操作的延迟行为主要是让流API能够更加高效地执行。</li>
</ul>
</li>
<li><p>stream不可复用，对一个已经进行过终端操作的流再次调用，会抛出异常。</p>
</li>
</ul>
<h4 id="7-5-1-流的创建"><a href="#7-5-1-流的创建" class="headerlink" title="7.5.1 流的创建"></a>7.5.1 流的创建</h4><p>我们一般是对集合或者数组进行流操作，流常规的创建方式有以下几种</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;
import java.util.Arrays;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Demo09 &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F;-- 针对数组
        int[] array &#x3D; &#123;1,2,3,4,5,6,7,8,9,10&#125;;
        &#x2F;&#x2F;-- 针对数组的流 要使用Arrays工具类  或者 使用Stream.of(值1，值2，。。。，值n)
        &#x2F;&#x2F;-- IntStream 继承了BaseStream
        &#x2F;&#x2F;-- Stream    继承了BaseStream
        IntStream stream1 &#x3D; Arrays.stream(array);
        Stream&lt;Integer&gt; stream2 &#x3D; Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9);

        &#x2F;&#x2F;-- 针对集合的
        ArrayList&lt;Character&gt; list &#x3D; new ArrayList&lt;&gt;();
        list.add(&#39;A&#39;);
        list.add(&#39;B&#39;);
        list.add(&#39;C&#39;);
        list.add(&#39;D&#39;);
        list.add(&#39;E&#39;);
        list.add(&#39;F&#39;);
        list.add(&#39;G&#39;);

        &#x2F;&#x2F;-- 普通流
        Stream&lt;Character&gt; stream3 &#x3D; list.stream();

        &#x2F;&#x2F;-- 将普通流转变成并行流
        Stream&lt;Character&gt; stream3_1 &#x3D; stream3.parallel();

        &#x2F;&#x2F;-- 并行流。 对并行操作支持的！
        Stream&lt;Character&gt; stream4 &#x3D; list.parallelStream();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="7-5-2-流的中间操作和终端操作"><a href="#7-5-2-流的中间操作和终端操作" class="headerlink" title="7.5.2 流的中间操作和终端操作"></a>7.5.2 流的中间操作和终端操作</h4><p>消费掉流对象的操作就被叫做终端操作。。</p>
<p><img src="/2022/11/26/javase/stream.jpeg"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Random;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Demo10 &#123;
    public static void main(String[] args) &#123;

        &#x2F;&#x2F;-- 针对集合的
        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();
        Random random &#x3D; new Random();
        for (int i &#x3D; 0; i &lt; 20; i++) &#123;
            list.add(random.nextInt(15) + 5);
        &#125;

        System.out.println(&quot;流处理前:&quot; + list);

        &#x2F;&#x2F;-- 普通流
        Stream&lt;Integer&gt; stream &#x3D; list.stream();

        &#x2F;&#x2F;-- 中间操作： 去重
        Stream&lt;Integer&gt; steam1 &#x3D; stream.distinct();

        &#x2F;&#x2F;-- 中间操作：在去重的基础上排序  默认升序
        Stream&lt;Integer&gt; stream2 &#x3D; steam1.sorted();

        &#x2F;&#x2F;--  中间操作：筛选 只要15以上的数字
        &#x2F;&#x2F;-- filter 过滤的意思！
        &#x2F;&#x2F;stream2.filter(new Predicate&lt;Integer&gt;() &#123;
        &#x2F;&#x2F;    @Override
        &#x2F;&#x2F;    public boolean test(Integer integer) &#123;
        &#x2F;&#x2F;        return false;
        &#x2F;&#x2F;    &#125;
        &#x2F;&#x2F;&#125;);
        &#x2F;&#x2F;stream2.filter(i -&gt; &#123;return i &gt; 15;&#125;);
        Stream&lt;Integer&gt; stream3 &#x3D; stream2.filter(i -&gt; i &gt; 15);


        &#x2F;&#x2F;-- 终端操作：打印
        &#x2F;&#x2F;stream3.forEach(new Consumer&lt;Integer&gt;() &#123;
        &#x2F;&#x2F;    @Override
        &#x2F;&#x2F;    public void accept(Integer integer) &#123;
        &#x2F;&#x2F;
        &#x2F;&#x2F;    &#125;
        &#x2F;&#x2F;&#125;);
        &#x2F;&#x2F;stream3.forEach(i-&gt; System.out.println(i));
        &#x2F;&#x2F;stream3.forEach(System.out::println);

        &#x2F;&#x2F;-- 合并上面的所有代码
        list.stream().distinct().sorted((o1, o2) -&gt; o2 - o1).filter(i -&gt; i&gt;15).forEach(System.out::println);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;
import java.util.Random;

public class Demo11 &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;User&gt; list &#x3D; new ArrayList&lt;&gt;();
        Random random &#x3D; new Random();
        for (int i &#x3D; 0; i &lt; 10; i++) &#123;
            list.add(new User(i+1,random.nextInt(15)+5,&quot;张&quot;+i,random.nextBoolean()?&quot;男&quot;:&quot;女&quot;));
        &#125;

        System.out.println(&quot;Stream 处理前&quot;);
        for (User user : list) &#123;
            System.out.println(user);
        &#125;
        System.out.println(&quot;###############&quot;);

        &#x2F;&#x2F;-- distinct 去重的原理把元素放到HashSet中，Set去重的依据是 equals和hashCode
        &#x2F;&#x2F;list.stream().sorted((u1,u2)-&gt;u2.getUserAge() - u1.getUserAge()).filter(u-&gt;u.getUserAge()&gt;15).forEach(System.out::println);
        list.stream().sorted((u1,u2)-&gt;u2.getUserAge() - u1.getUserAge()).filter(u-&gt;u.getUserGender().equals(&quot;男&quot;)).forEach(System.out::println);
    &#125;
&#125;

class User&#123;
    private Integer userId;
    private Integer userAge;
    private String userName;
    private String userGender;

    public User() &#123;
    &#125;

    public User(Integer userId, Integer userAge, String userName, String userGender) &#123;
        this.userId &#x3D; userId;
        this.userAge &#x3D; userAge;
        this.userName &#x3D; userName;
        this.userGender &#x3D; userGender;
    &#125;

    public Integer getUserId() &#123;
        return userId;
    &#125;

    public void setUserId(Integer userId) &#123;
        this.userId &#x3D; userId;
    &#125;

    public Integer getUserAge() &#123;
        return userAge;
    &#125;

    public void setUserAge(Integer userAge) &#123;
        this.userAge &#x3D; userAge;
    &#125;

    public String getUserName() &#123;
        return userName;
    &#125;

    public void setUserName(String userName) &#123;
        this.userName &#x3D; userName;
    &#125;

    public String getUserGender() &#123;
        return userGender;
    &#125;

    public void setUserGender(String userGender) &#123;
        this.userGender &#x3D; userGender;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
                &quot;userId&#x3D;&quot; + userId +
                &quot;, userAge&#x3D;&quot; + userAge +
                &quot;, userName&#x3D;&#39;&quot; + userName + &#39;\&#39;&#39; +
                &quot;, userGender&#x3D;&#39;&quot; + userGender + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="7-6-Map"><a href="#7-6-Map" class="headerlink" title="7.6 Map"></a>7.6 Map</h3><h4 id="7-6-1-Map诞生的原因"><a href="#7-6-1-Map诞生的原因" class="headerlink" title="7.6.1 Map诞生的原因"></a>7.6.1 Map诞生的原因</h4><p>Map 在有些语言中被叫做映射或者散列或者字典。它是一个双列集合，同时存储两份数据。一个是key一个是value，所以也被叫做key-value 键值对。</p>
<p>使用List它的查询效率很低，一个长度为N的List，它的查询效率最好的是O(1)最差的是O(N)。效率这么低的原因是我们要遍历整个List然后取每一个元素进行判断比较。所有查询效率的高低完全取决于匹配的次数。</p>
<p>查询是有查询算法：二分，但是还是有匹配次数的，我们希望把匹配次数降低到最低：1次都不比较。这就相当于我们在存储数据时必须要同时记录，数据的存储位置。这样我们就需要同时保存数据和数据的存储位置两份数据。所以它被叫做双列。</p>
<p>在数据结构上，这样的数据结构被叫做散列</p>
<h4 id="7-6-2-散列的基本实现"><a href="#7-6-2-散列的基本实现" class="headerlink" title="7.6.2 散列的基本实现"></a>7.6.2 散列的基本实现</h4><p>无论是多么复杂的数据结构，最终都是依赖于数组或者链表两种结构实现的。散列的实现是基于数组的。散列的基本算法是求余发法。我们在内存中开辟一个数组空间，假设数组的长度为N，我们要存储一个元素X，我么们用X除以N求余数，得到数组中的一个索引 I ，然后把元素X放到索引 I 对应的空间内。元素和位置就形成一张表，这张表被叫做散列表，计算索引的函数被叫做散列函数，用h来表示。</p>
<p><img src="/2022/11/26/javase/map.png"></p>
<p>如果一个数组的大小为11，我们实际存储了6个数据在内，那空间的使用率就是6/11。这个值有个术语叫做负载因子。</p>
<h4 id="7-6-3-Collision"><a href="#7-6-3-Collision" class="headerlink" title="7.6.3 Collision"></a>7.6.3 Collision</h4><p>散列碰撞</p>
<p>我们的数组长度为11，那么在求余数的时候是会遇到不同的数据计算出来的索引值一样的现象：比如元素22，33，44，55，66，77等这些元素求11的余数都是0，表示这些元素都要放在0号索引所对应的空间内。即不同的元素经过hash函数计算得到相同的hashCode。这种现象被叫做hash碰撞。</p>
<p>Hash碰撞是无法避免的(不要抬杠，有完美散列，但是代价太大了，保存3个11位数的手机号，需要开辟12位数的内存空间。它的性价比太低没人会为了完美而浪费如此多的空间)，但是冲突也不是完全无法接收的，我们要把冲突的影响控制在一个最低的范围！</p>
<p>解决冲突常规有两种方案</p>
<ul>
<li><p>开放寻址 open addressing     从冲突的槽位开始向后寻找一个空槽来盛放元素，如果找到末尾还没有找到则从头再找一边</p>
</li>
<li><p>线性探测：linear probing</p>
</li>
<li><p>转链表</p>
</li>
</ul>
<h4 id="7-6-4-JDK1-8的Map实现"><a href="#7-6-4-JDK1-8的Map实现" class="headerlink" title="7.6.4 JDK1.8的Map实现"></a>7.6.4 JDK1.8的Map实现</h4><p>Java 的 散列函数是基于 数组 + 链表  + 红黑树来实现的。因为我们使用hash的目的是提高查询速度。但是当碰撞的次数变多，链表的长度会过长。链表想要查找元素还是需要循环遍历比较。就导致我们的查询效率又降低了。所以为了提高它的查询效率，在链表的长度超过一个阈值时，将链表变成红黑树（红黑树左右分支一样长，是一颗平衡的二叉树）。并且在红黑树中进行查找相当于进行折半查找。</p>
<h4 id="7-6-5-HashMap的基本使用"><a href="#7-6-5-HashMap的基本使用" class="headerlink" title="7.6.5  HashMap的基本使用"></a>7.6.5  HashMap的基本使用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.*;

public class Demo05 &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F;-- 根据key来计算hashCode，然后存储value。取value时，要根据key来取值
        HashMap&lt;String,String&gt; map &#x3D; new HashMap&lt;&gt;();
        map.put(&quot;中国&quot;,&quot;人民解放军&quot;);
        map.put(&quot;美国&quot;,&quot;美国大兵&quot;);
        map.put(&quot;德国&quot;,&quot;坦克杀手&quot;);
        map.put(&quot;英国&quot;,&quot;狙击手&quot;);
        map.put(&quot;法国&quot;,&quot;巨炮&quot;);
        map.put(&quot;伊拉克&quot;,&quot;辐射兵&quot;);
        map.put(&quot;利比亚&quot;,&quot;自爆卡车&quot;);
        map.put(&quot;俄罗斯&quot;,&quot;地磁坦克&quot;);

        &#x2F;&#x2F;-- 放入和取出的顺序不一致，所以map是无序的
        &#x2F;&#x2F;-- 一般说序有两个单词：一个是顺序（order） 一个是排序（sort）
        &#x2F;&#x2F;-- map可以排序吗？ HashMap是无序且无法排序的。因为固定按照散列表（数组）的顺序来输出
        System.out.println(map);

        &#x2F;*
            map.put(&quot;中国&quot;,&quot;人民解放军&quot;)
                    h(&quot;中国&quot;) -》 索引
                    array[索引] -》 人民解放军

            map.get(&quot;中国&quot;)
                    h(&quot;中国&quot;) - 》 索引
                    String str &#x3D; array[索引]

             h() 就是散列函数-》hashCode

         *&#x2F;
        String value &#x3D; map.get(&quot;中国&quot;);
        System.out.println(value);

        &#x2F;&#x2F;-- map没有迭代器  ，加强for循环也不能用！
        &#x2F;&#x2F;-- 对于map的遍历，寻找了一个折中的方案： 只对键遍历，只对值遍历，和键值对遍历
        &#x2F;&#x2F;-- map的键是唯一的，List中允许有重复数据，Set中没有重复性数据
        Set&lt;String&gt; keys &#x3D; map.keySet();

        for (String key : keys) &#123;
            System.out.println(key + &quot;#&quot; + map.get(key));
        &#125;

        &#x2F;&#x2F;-- map的键是不可以重复的，但是值是可以重复的。
        &#x2F;&#x2F;-- 父类越大，能接收的子类越多,
        Collection&lt;String&gt; values &#x3D; map.values();
        &#x2F;&#x2F;-- 转成list
        &#x2F;&#x2F;ArrayList&lt;String&gt; list1 &#x3D; new ArrayList&lt;&gt;(values);
        &#x2F;&#x2F;LinkedList&lt;String&gt; list2 &#x3D; new LinkedList&lt;&gt;(values);
        &#x2F;&#x2F;LinkedList&lt;String&gt; list3 &#x3D; new LinkedList&lt;&gt;();
        &#x2F;&#x2F;ArrayList&lt;String&gt; list4 &#x3D; new ArrayList&lt;&gt;(values);
        &#x2F;&#x2F;list4.addAll(values);
        &#x2F;&#x2F;list3.addAll(values);

        Iterator&lt;String&gt; iterator &#x3D; values.iterator();
        while (iterator.hasNext())&#123;
            String val &#x3D; iterator.next();
            System.out.println(val);
        &#125;

        &#x2F;&#x2F;--
        System.out.println(map.containsKey(&quot;中国&quot;));
        System.out.println(map.containsValue(&quot;美国大兵&quot;));

        &#x2F;&#x2F;-- containsKey和containsValue 理论上应该是遍历所有的键或者值，然后进行判断是否有值和传入的相等
        &#x2F;&#x2F;-- 我们学过的判断是否相等有两种方式:原生的&#x3D;&#x3D;和引用的equals
        &#x2F;&#x2F;-- &lt;&gt; 代表泛型 里面只能放引用！


    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="7-6-6-练习，要求-：-提供要给数组长度为20里面随机生成5-15之间的随机数，求每个数出现的次数"><a href="#7-6-6-练习，要求-：-提供要给数组长度为20里面随机生成5-15之间的随机数，求每个数出现的次数" class="headerlink" title="7.6.6 练习，要求 ： 提供要给数组长度为20里面随机生成5-15之间的随机数，求每个数出现的次数"></a>7.6.6 练习，要求 ： 提供要给数组长度为20里面随机生成5-15之间的随机数，求每个数出现的次数</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;

public class Demo08 &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F;-- 1.创建数组 长度20
        int[] array &#x3D; new int[20];
        &#x2F;&#x2F;-- 2.创建Random -》用于生成随机数
        &#x2F;&#x2F;-- seed 是种子 所有的随机数都是伪随机数。它是一套固定的算法，基于某一个值进行计算然后得到的结果就是随机数
        &#x2F;&#x2F;-- 一般情况下是基于系统时间毫秒数。一旦我们指定了seed就不再基于系统时间的毫秒数进行计算。而是基于我们给定的
        &#x2F;&#x2F;-- seed 进行计算
        Random random &#x3D; new Random(1);
        &#x2F;&#x2F;-- 3.遍历数组，赋值随机数 25~37
        for (int i &#x3D; 0; i &lt; array.length; i++) &#123;
            array[i] &#x3D; random.nextInt(13) + 25;
        &#125;
        System.out.println(Arrays.toString(array));
        &#x2F;&#x2F;-- 4.声明Map
        HashMap&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();
        &#x2F;&#x2F;-- 5.遍历数组，取每一个元素作为map的key，判断该key是否存在，存在取出value+1，不存在value赋值为1
        for (int element : array) &#123;
            if (map.containsKey(element)) &#123;
                map.put(element, map.get(element) + 1);
            &#125; else &#123;
                map.put(element, 1);
            &#125;
        &#125;
        System.out.println(map);
        

    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在Map接口中有内部接口：Entry，它是Map存储数据的单位。一个键值对就是一个Entry。</p>
<p><img src="/2022/11/26/javase/map1.png"></p>
<p>直接使用Stream对Map的内容进行排序</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static Map&lt;String, Integer&gt; sortMapByKey(Map&lt;String, Integer&gt; map) &#123;
    Map&lt;String, Integer&gt; collect &#x3D; map.entrySet().stream()
            .sorted(Map.Entry.comparingByKey())
            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,(oldVal, newVal) -&gt; newVal, LinkedHashMap::new));
    return collect;

&#125;

public static Map&lt;String, Integer&gt; sortMapByValue(Map&lt;String, Integer&gt; map) &#123;
    Map&lt;String, Integer&gt; collect &#x3D; map.entrySet().stream()
            .sorted(Map.Entry.comparingByValue())
            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,(oldVal, newVal) -&gt; newVal, LinkedHashMap::new));
    return collect;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="7-7-链表"><a href="#7-7-链表" class="headerlink" title="7.7 链表"></a>7.7 链表</h3><h4 id="7-7-1-链表的概念"><a href="#7-7-1-链表的概念" class="headerlink" title="7.7.1 链表的概念"></a>7.7.1 链表的概念</h4><p>ArrayList 是基于数组实现的，那么数组的特点和弊端，ArrayList都具备。</p>
<ul>
<li><p>优点</p>
</li>
<li><ul>
<li>内存连续-》遍历速度快</li>
</ul>
</li>
<li><p>缺点</p>
</li>
<li><ul>
<li>有M个长度的数组，在N号位置插入元素或者删除元素，从N+1开始到M截至的所有元素都需要移位</li>
</ul>
</li>
</ul>
<p>如果使用ArrayList进行频繁的删除，效率并不高。为了解决这个问题，我们创建了一种新的数据结构：链表。链表最典型的特点：内存不连续。链表采用节点（Node）来存储数据。每一个节点分为两部分：一是数据区，二是地址区。数据区保存要存储的数据，而地址区保存上一个节点或者下一个节点的地址。通过这种方式把所有的节点串起来，构成链表。</p>
<p><img src="/2022/11/26/javase/del.png"></p>
<p>所有链表的特点</p>
<ul>
<li>优点  内存不连续，增删效率高</li>
<li>缺点  内存不连续，遍历速度慢。多了个寻址的过程。</li>
</ul>
<p><img src="/2022/11/26/javase/del2.png"></p>
<p>当频繁需要增删时，优先选择链表。</p>
<h4 id="7-7-2-链表的实现"><a href="#7-7-2-链表的实现" class="headerlink" title="7.7.2 链表的实现"></a>7.7.2 链表的实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo12 &#123;

   static class Node&#123;
        &#x2F;&#x2F;-- 数据区
        Object obj;
        &#x2F;&#x2F;-- 地址区 保存上下节点的地址，如果同时保存叫做双向链表，如果只保存一个叫做单项链表，如果头和尾是同一个则是循环链表
        &#x2F;&#x2F;-- 这里我们只用单向链表（只保存下一个），Java 的 链表：LinkedList 是双向链表。
        &#x2F;&#x2F;-- 我们通过引用变量来操作对象！
        Node next;

       public Node(Object obj, Node next) &#123;
           this.obj &#x3D; obj;
           this.next &#x3D; next;
       &#125;
   &#125;

    public static void main(String[] args) &#123;
        Node n1 &#x3D; new Node(&quot;A&quot;,null);
        Node n2 &#x3D; new Node(&quot;C&quot;,null);
        Node n3 &#x3D; new Node(&quot;E&quot;,null);
        Node n4 &#x3D; new Node(&quot;G&quot;,null);
        Node n5 &#x3D; new Node(&quot;I&quot;,null);


        &#x2F;&#x2F;-- 目标：n1 -&gt;n2 -&gt;n3 -&gt;n4 -&gt;n5
        n1.next &#x3D; n2;
        n2.next &#x3D; n3;
        n3.next &#x3D; n4;
        n4.next &#x3D; n5;
        n5.next &#x3D; null;

        &#x2F;&#x2F;-- 遍历整个链表！
        &#x2F;&#x2F;-- 新建node 的目的是保证n1的指向不变！
        Node node &#x3D; n1;
        &#x2F;&#x2F;-- 当node.next 不为空时，表示有下一个节点。取下一个节点！
        while(null !&#x3D; node.next)&#123;
            System.out.println(node.obj);
            node &#x3D; node.next;
        &#125;
        &#x2F;&#x2F;-- 上面循环少了最后一个元素，所有要补上！
        System.out.println(node.obj);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>需求：在索引位3的位置插入元素Z</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo13 &#123;
    &#x2F;&#x2F;-- 持有的头
    private Node header;
    private int size &#x3D; 0;
    static class Node&#123;
        Object obj;
        Node next;

        public Node(Object obj, Node next) &#123;
            this.obj &#x3D; obj;
            this.next &#x3D; next;
        &#125;
    &#125;

    public void add(Object obj)&#123;
        if (header &#x3D;&#x3D; null)&#123;
            Node node &#x3D; new Node(obj,null);
            header &#x3D; node;
        &#125;else&#123;
            &#x2F;&#x2F;-- 顺序添加 找到末尾的null
            Node temp &#x3D; header;
            while (temp.next!&#x3D;null)&#123;
                temp &#x3D; temp.next;
            &#125;
            &#x2F;&#x2F;-- temp就是最后一个元素
            Node node &#x3D; new Node(obj,null);
            temp.next &#x3D; node;
        &#125;
        size ++;
    &#125;

    public void add(int index,Object obj)&#123;
        if(index &gt; size)&#123;
            throw new ArrayIndexOutOfBoundsException(&quot;size:&quot; + size + &quot;index:&quot; + index);
        &#125;

        if (index &#x3D;&#x3D; 0 &amp;&amp; header &#x3D;&#x3D; null)&#123;
            Node node &#x3D; new Node(obj,null);
            header &#x3D; node;
        &#125;else&#123;
            &#x2F;&#x2F;--  A  B C D E F
            &#x2F;&#x2F;--  0  1 2 3 4 5
            &#x2F;&#x2F;-- index &#x3D; 3
            &#x2F;&#x2F;-- A B C Z D E F
            Node temp &#x3D; header;
            &#x2F;*
                i的值   index的值  节点的内容  节点的next
                0        3           A         B
                1        3           B         C
                2        3           C         D
                3        3           D
             *&#x2F;
            for (int i &#x3D; 0; temp.next !&#x3D; null ; i++) &#123;
                if (i &#x3D;&#x3D; (index - 1))&#123;
                    break;
                &#125;
                temp &#x3D; temp.next;
            &#125;
            &#x2F;&#x2F;-- temp 就是要插入位置的前一个节点
            Node oldNext &#x3D; temp.next;
            temp.next &#x3D; new Node(obj,oldNext);
        &#125;
    &#125;


    public void forEach()&#123;
        Node temp &#x3D; header;
        while (temp.next !&#x3D; null)&#123;
            System.out.println(temp.obj);
            temp &#x3D; temp.next;
        &#125;
        System.out.println(temp.obj);
    &#125;

    public static void main(String[] args) &#123;
        Demo13 d &#x3D; new Demo13();
        d.add(&quot;A&quot;);
        d.add(&quot;B&quot;);
        d.add(&quot;C&quot;);
        d.add(&quot;D&quot;);
        d.add(&quot;E&quot;);

        d.forEach();

        System.out.println(&quot;#&quot;);
        d.add(3,&quot;Z&quot;);
        d.forEach();
    &#125;
&#125;
public class Demo01 &#123;
    &#x2F;&#x2F;-- 写在一个class里面的才是内部类
    class Node&#123;
        private Object obj;
        private Node next;

        public Node(Object obj,Node next)&#123;
            this.obj &#x3D; obj;
            this.next &#x3D; next;
        &#125;
    &#125;

    private Node header;
    private int size &#x3D; 0;

    public void add(Object obj)&#123;
        &#x2F;&#x2F;-- header 有两种处理思路：可以保存数据，也可以不保存
        if (header &#x3D;&#x3D; null)&#123;
            header &#x3D; new Node(obj,null);
        &#125;else&#123;
            Node temp &#x3D; header;
            while (temp.next !&#x3D; null)&#123;
                temp &#x3D; temp.next;
            &#125;
            temp.next &#x3D; new Node(obj,null);
        &#125;
        size++;
    &#125;

    public void add(int index,Object obj)&#123;
        if (index &gt; size)&#123;
            throw  new ArrayIndexOutOfBoundsException(&quot;size:&quot; + size + &quot;index:&quot; + index);
        &#125;

        if (header &#x3D;&#x3D; null)&#123;
            header &#x3D; new Node(obj,null);
        &#125;else&#123;
            Node temp &#x3D; header;
            for (int i &#x3D; 0; temp.next !&#x3D; null; i++) &#123;
                if (i &#x3D;&#x3D; index - 1)&#123;
                    break;
                &#125;
                temp &#x3D; temp.next;
            &#125;
            &#x2F;&#x2F;-- 目标：2这个位置 插入F
            &#x2F;&#x2F;--  A B C D
            &#x2F;&#x2F;--  0 1 2 3
            &#x2F;&#x2F;-- 此时的temp &#x3D;》B  让原本的B指向C的连接断开，让B指向F，然后让F指向C
            Node odlNext &#x3D; temp.next;
            temp.next &#x3D; new Node(obj,odlNext);
            size++;
        &#125;


    &#125;

    public void remove()&#123;
        if (size &#x3D;&#x3D; 0)&#123;
            throw new ArrayIndexOutOfBoundsException(&quot;size: &quot;  + size + &quot;index:&quot; + size);
        &#125;

        Node temp &#x3D; header;
        while (temp.next.next !&#x3D; null)&#123;
            temp &#x3D; temp.next;
        &#125;
        temp.next &#x3D; null;
    &#125;

    public void remove(Object obj)&#123;
        &#x2F;&#x2F;-- A B C D E F
        &#x2F;&#x2F;-- 删除C ： 至少要有B
        &#x2F;&#x2F;-- B.next &#x3D;&gt; C  C.next &#x3D;&gt; D
        &#x2F;&#x2F;-- B.next &#x3D; B.next.next;

        if (size &#x3D;&#x3D; 0 || header &#x3D;&#x3D; null)&#123;
            throw new ArrayIndexOutOfBoundsException();
        &#125;

        Node temp &#x3D; header;
        boolean flag &#x3D; false;
        while (temp.next !&#x3D; null)&#123;

            if (temp.next.obj.equals(obj))&#123;
                temp.next &#x3D; temp.next.next;
                flag &#x3D; true;
                break;
            &#125;

            temp&#x3D; temp.next;
        &#125;
        if (flag)&#123;
            System.out.println(&quot;删除成功&quot;);
        &#125;else&#123;
            System.out.println(&quot;要删除的元素不存在&quot;);
        &#125;
    &#125;

    public void printLinkedList()&#123;
        Node temp &#x3D; header;
        while (temp.next !&#x3D; null)&#123;
            System.out.print(temp.obj  + &quot;\t&quot;);
            temp &#x3D; temp.next;
        &#125;
        System.out.println(temp.obj);
    &#125;

    public static void main(String[] args) &#123;
        Demo01 d &#x3D; new Demo01();
        d.add(&quot;A&quot;);
        d.add(&quot;B&quot;);
        d.add(&quot;C&quot;);
        d.add(&quot;D&quot;);
        d.add(&quot;E&quot;);

        d.printLinkedList();

        d.add(3,&quot;Z&quot;);
        d.add(1,&quot;F&quot;);

        d.printLinkedList();

        d.remove();

        d.printLinkedList();

        d.remove(&quot;B&quot;);

        d.printLinkedList();

    &#125;

&#125;


&#x2F;&#x2F;-- 一个源文件中可以有很多类（外部类），但是有且只有一个被public修饰，
class Node2&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<table>
<thead>
<tr>
<th>方法名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>new LinkedList&lt;&gt;()</td>
<td>构建一个LinkedList对象</td>
</tr>
<tr>
<td>new LinkedList(Collection&lt;? extends E&gt; c)</td>
<td>根据一个已有的Collection来构建一个LinkedList，比如把Set,ArrayList变成一个LinkedList就可以使用该方法。</td>
</tr>
<tr>
<td>size()</td>
<td>返回集合中元素的个数</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>判断集合中是否有元素，利用 return size() == 0; 来实现</td>
</tr>
<tr>
<td>add()  | addLast =》 linklast</td>
<td>末尾添加元素</td>
</tr>
<tr>
<td>addFirst | push =》 linkFirst</td>
<td>头部添加元素</td>
</tr>
<tr>
<td>add(int index, E element)</td>
<td>指定位置添加元素。index的取值范围=》【0，size】，超出这个范围下标越界</td>
</tr>
<tr>
<td>set(int index, E element)</td>
<td>替换指定位置的元素。index取值范围=》【0，size】，超出这个范围下标越界</td>
</tr>
<tr>
<td>get(int index)</td>
<td>根据索引取值。index取值范围=》【0，size】，超出这个范围下标越界</td>
</tr>
<tr>
<td>getFirst()  | element()</td>
<td>返回第一个元素，如果List为空，则抛出NoSuchElementException</td>
</tr>
<tr>
<td>getLast()</td>
<td>返回最后一个元素，如果List为空，则抛出NoSuchElementException</td>
</tr>
<tr>
<td>peek()</td>
<td>效果和getFirst()一样，都是获取第一个元素，但是如果链表为空，它不会抛出异常，会返回null</td>
</tr>
<tr>
<td>peekFirst()</td>
<td>同上-》获取第一个元素</td>
</tr>
<tr>
<td>peekLast()</td>
<td>获取最后一个元素，效果和getLast一致，但是如果链表为空，它不会抛出异常，会返回null</td>
</tr>
<tr>
<td>remove()</td>
<td>等价于 removeFirst() 删除第一个元素，如果链表为空，则抛出NoSuchElementException 异常。</td>
</tr>
<tr>
<td>remove(index)</td>
<td>移除指定索引对应的元素，索引范围：【0，size），如果超出范围抛出IndexOutOfBoundsException异常</td>
</tr>
<tr>
<td>remove(Object)</td>
<td>移除指定的元素，如果集合中不包含元素，则不作任何改变。通过什么来判断是否包含：equals，所以自定义类型要重写equals方法。</td>
</tr>
<tr>
<td>removeFirst()  | pop()</td>
<td>参考：remove（）</td>
</tr>
<tr>
<td>removeLast()</td>
<td>移除最后一个元素，如果链表为空则抛出：NoSuchElementException异常</td>
</tr>
<tr>
<td>poll()</td>
<td>移除第一个元素，如果链表为空则返回null，不会产生异常</td>
</tr>
<tr>
<td>pollFirst()</td>
<td>移除第一个元素，如果链表为空则返回null，不会产生异常</td>
</tr>
<tr>
<td>pollLast()</td>
<td>移除最后一个元素，如果链表为空则返回null，不会产生异常</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="7-8-Set"><a href="#7-8-Set" class="headerlink" title="7.8 Set"></a>7.8 Set</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.HashMap;
import java.util.HashSet;

public class Demo10 &#123;
    public static void main(String[] args) &#123;
        HashSet&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();
        boolean result &#x3D; set.add(&quot;A&quot;);
        System.out.println(result);
        System.out.println(set);

        result &#x3D; set.add(&quot;A&quot;);
        System.out.println(result);
        System.out.println(set);

        result &#x3D; set.add(&quot;B&quot;);
        System.out.println(result);
        System.out.println(set);
        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&quot;);
        
        HashMap&lt;String,String&gt; map &#x3D; new HashMap&lt;&gt;();
        String value &#x3D; map.put(&quot;A&quot;, &quot;1&quot;);
        System.out.println(value);
        value &#x3D; map.put(&quot;A&quot;, &quot;11&quot;);
        System.out.println(value);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Set 最核心的一个问题，它是如何去重的。Set以HashSet为例，它是使用HashMap的键来存储数据的。所以与其说Set如何去重，不如说HashMap的键如何去重！我们回想一下散列算法以及碰撞处理。</p>
<p><img src="/2022/11/26/javase/set.png"></p>
<p>HashMap的Key保证唯一性的依据是：hashCode和equals两个方法。先执行HashCode，再执行Equals。HashCode确保是不是同一个空间，Equals确保是不是同一个值。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Gao Jian</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2022/11/26/javase/">http://example.com/2022/11/26/javase/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Gao Jian</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Study/">
                                    <span class="chip bg-color">Study</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/11/26/bootstrap/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="BootStrap">
                        
                        <span class="card-title">BootStrap</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-11-26
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/BootStrap/" class="post-category">
                                    BootStrap
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Study/">
                        <span class="chip bg-color">Study</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/11/23/jquery/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="JQuery">
                        
                        <span class="card-title">JQuery</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-11-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JQuery/" class="post-category">
                                    JQuery
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Study/">
                        <span class="chip bg-color">Study</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>





    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Gao Jian</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">44.3k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/gaojiancoder" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:gaojian_liap@outlook.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2651366728" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2651366728" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://gaojiancoder.github.io" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://gaojiancoder.github.io" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>





</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    


        <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

</body>

</html>
